# 0. JSX
- 是javaScripth和XML的缩写，在js中写html
- {} 用法
  - 使用引号传递字符串
  - 识别js变量
  - 函数调用
  - 识别js对象


# 1. useState: 使用状态
   - 是React Hook函数（数据驱动视图）
   - 状态不可变： 状态是只读的，因该替换而非修改
  ## 基本模板
  ```js
    function App () {
      // 1.count    状态变量
      // 2.setCount 修改count的方法
      const [count，setCount]= useState(0)
      const handleClick=()=>{ setCount(count+ 1) }
      return (
        <button onClick={handleClick}>{count}</button>
      )
    }
  ```

  ## 场景1：受控表单绑定
  ```js
    const [value, setValue] = useState('')
    const onChange = { (e) => setValue(e.target.value) }
    return {
      <inupt type="text" value={value} onChange />
    } 
  ```

# 2. useRef：DOM绑定
  - 随机数： pnpm i uuid
  - import {v4 as uuidV4} from 'uuid'
  - 标准日期： pnpm i dayjs

# 3. useEffect：渲染本身
  useEffect(() => {}, [])
  1. 如Ajax, 更改dom
  2. 数据获取
  3. 清除副作用： 在组件卸载时执行 clearInterval(timer)

  useEffect(() => {})          无依赖项,      组件初始渲染+组件更新时执行
  useEffect(() => {}, [])      空数组依赖,     只在初始渲染时执行一次 
  useEffect(() => {}, [count]) 添加特定依赖项, 特性依赖向变化时执行


# 4. useRender: 复杂的状态管理
  1. 先 创建一个reducer。管理 多个状态
  ```js
    function reducer(state, action)
  ```
  2. 初始化状态
  3. useReducer 返回由两个值:（1）state（2） dispatch 函数，可根据交互修改 state。
  ```js
  const [state, dispatch] = useReducer(reducer, initialState);
  ```
  4. 执行dispatch
  5. 使用state

  ## useRender优点： 
    避免重新创建初始值 
    React 会保存 state 的初始值并在下一次渲染时忽略它。

```js
import { useReducer } from 'react';
// 1. 先 创建一个reducer。管理 多个状态
function reducer(state, action) {
  switch (action.type) {
    case 'incremented_age': {
      return {
        name: state.name,
        age: state.age + 1
      };
    }
    case 'changed_name': {
      return {
        name: action.nextName, // 实时更新成 输入框的内容
        age: state.age
      };
    }
  }
  throw Error('Unknown action: ' + action.type);
}
// 2. 初始化状态
const initialState = { name: 'Taylor', age: 42 };

export default function Form() {

// 3. useReducer 返回由两个值:（1）state（2） dispatch 函数，可根据交互修改 state。
  const [state, dispatch] = useReducer(reducer, initialState);

// 4. 执行dispatch
  function handleButtonClick() {
    dispatch({ type: 'incremented_age' });
  }

  function handleInputChange(e) {
    dispatch({
      type: 'changed_name',
      nextName: e.target.value
    });
  }
// 5. 使用state
  return (
    <>
      <input value={state.name} onChange={handleInputChange}/>
      <button onClick={handleButtonClick}>增加 age</button>
      <p>Hello, {state.name}. You are {state.age}.</p>
    </>
  );
  }
```

# 5. useMemo 与 React.memo
  (1) useMemo作用： 
    每次重新渲染时，缓存计算的结果, 跳过代价昂贵的重复计算
  (2) React.memo作用：
    允许子组件在Props没有改变的情况下，跳过渲染
  ## （1）useMemo
      const cachedValue = useMemo(calculateValue, dependencies)
  ```js
    const result = useMemo(() => {
      return fib(count1);// 斐波那契函数，是一个耗性能的计算
    }, [count1]); // count1是依赖项
  ```
  
  ## （2）React.memo
  ```js
  const MyComponent = React.memo(function MyComponent(props) {
      /* 只有props改变时，这个组件才会重新渲染 */
      return <div>{props.text}</div>;
  });
  ```





# 4. 自定义hook
## 4.1 用法
  - 声明use开头的函数
  - 在函数体内封装可复用的逻辑
  - 把组件中用到的状态或者回调函数 return出去 
  - 在每一个组件中解构此hook

```js
  import { useState } from "react"

  function useToggle(){
  // 可复用的逻辑代码
  const [value,setValue]= useState(true)
  const toggle=()=> setValue(!value)
  // 哪些状态和回调函数需要在其他组件中使用
  return return {
    value,
    toggle
  }
 }
```
## 4.2 使用规则
  - 只能在组件中或者其他自定义hook中使用
  - 只能在组件顶层调用，不能嵌套在if、for、其他函数中 

## 4.4 用户自定义hook封装数据请求
```js
  function useGetList (){
    // 获取接口数据渲染
    const [commentList,setCommentList]= useState([])
    useEffect(() => {
      //请求数据
      async function getList ({
        // axios请求数据
        const res = await axios.get('localhost:3004/list')
        setCommentList(res.data)
    }
    getList()
    }，[])

    return {
      commentList, 
      setCommentList
    }
  }
```

## 5. useMemo

# 5. 常见功能
## 5.1 渲染列表 - list.map
```js
const list = [
  {id: 101, name: 'Vue'}，
  {id: 102, name: 'React'}，
  {id: 103, name: 'Angular'}，
]
______________________________________________
<ul>
  { list.map(item => <li key={item.id}>{item.name}</li> ) }
</ul>
```

## 5.2 条件渲染
```js
  const articleType = 1 //0 1 3

  function getArticleTem(){ // 条件渲染模板
    if (articleType --0){
      return <div>我是无图文章</div>
    } else if (articleType1){ 
      return <div>我是单图模式</div>
    }else {
      return <div>我是三图模式</div>
    }
  }
______________________________________________
  function App() { 
    return (
      <div className="App">
        {getArticleTem()}{/* 调用函数渲染不同的模版 */}
      </div>
    )
  }
  export default App
```
## 5.3 删除功能 - list.filter

```js
  // 1. 使用useState维护list
  const [cList,setCList]= useState(list)
  // 删除功能
  const handleDelete =(id)=>{
    console.log(id)
    // 对cList做过滤处理
    setCList(cList.filter(item => item.rpid !==id))
  } 
```

## 【场景】 Tab高亮实现
```js
  // 1. 点击谁就把谁的type记录下来
  // 2.通过记录的type和每一项遍历时的type做匹配 控制激活类名的显
  const	[type，setType]= useState('hot')	
  const handleTabChange = (type) =>{ 
    console.log(type) 
    setType(type)
  }
  _____________________________
  {
    // 遍历时和每一项type匹配
    tabs.map(item =>
      <span
        key={item.type}
        onClick={() => handleTabChange(item.type)}
        className={`nav-item ${type=- item.type && 'active'}`}>{item.text}
      </span>)
  }
```




