# 1. 浏览器存储数据方案

浏览器常见的存储数据的方案一共有四种，分别是Cookie、LocalStorage、SessionStorage、IndexedDB

## 1.1 Cookie

Cookie主要被用于用户身份的验证，以及用户数据的持久性，主要是为了使无状态的HTTP在某些特殊场景变的有状态，主要体现在我们发送网络请求时，Cookie会被请求头携带，并可以被服务端进行接收，服务端就可以通过Cookie中存储的一些信息进行验证。

Cookie的存储大小只有4kb，这是每个HTTP请求都会携带Cookie，所以当我们的存储量过大时会使HTTP请求变慢；

### 1.1.1 Cookie的特性

Cookie存储在客户端，但是服务端和客户端都可以对其进行读取、设置、删除操作；
Cookie分为会话Cookie和持久性Cookie，前者是没有设置过期时间，只会在当前会话生命周期内存在，也就是说关掉当前页面，cookie就没了，后者则是设置了过期时间，只有超过过期时间使时，才会清除；
Cookie是以文本文件的格式进行存储的，查看读取十分方便，所以说最好不要放重要信息，否则可能会被窃取；

### 1.1.2 Cookie的属性

（1） domain（域）
告知了浏览器哪些域可以访问cookie，如果未指定，那就默认当前域，只有当前域的cookie才能被访问到，发起HTTP请求时，只有和请求地址相同的域或者子域的cookie才会被携带。
（2）path（路径）
此属性指定访问 cookie 的路径。除了将 cookie 限制到域之外，还可以通过路径来限制它。 路径属性为 Path=/store 的 cookie 只能在路径为/store或者它的子路径（/store/a）的请求中被携带访问。
（3）Expires/max-age（过期时间）
Expires是一个具体的时间，max-age是一个单位为秒的时间段，都代表了cookies的过期时间，超过了这个时间之后，cookie就会过期，不会在请求之间携带。
（4）secure
该属性规定了cookies只能通过https协议进行传输，值的类型为boolean或null。
（5）http-only
该属性规定了只有服务端可以访问或者通过请求头去设置cookie，而客户端只能进行发送，但是不能进行访问。
（6） samesite
该属性有三个值Strict、Lax、None，

第一个值代表严格的，完全禁止第三方cookie，只有当请求地址和当前页面同域才能携带cookie；
第二个值代表相对宽松，和第一种类似，但是导航到源站点的get请求除外，这种情况依然会携带cookie；
第三种表示非常宽松，无论是跨域还是同域，都会携带cookie，如果设置为None，必须设置secure属性，否则会被视为设置为lax来处理；

## 1.2 Storage

- localStorage  除非手动清除，否则会永久存在，
- sessionStorage后者只保存在当前会话中。

---

- localStorage和sessionStorage存储的键值对总是以字符串的形式储存，如果存储的信息是一个对象或者数字，也会转换成字符串类型；
- localStorage和sessionStorage存储的大小最多只有5M；

Storage的操作方法

```js
localStorage.setItem('name', 'Lee') // 给localstorage添加属性
localStorage.getItem('name') // 获取某个属性
localStorage.removeItem('name') // 删除某个属性
localStorage.clear() // 清空storage
```

## 1.3 IndexedDB

- 它是为了解决存储大量的结构化数据而产生的，如果只是少量数据的话，直接使用Storage即可；
- 它是一个事务型数据库系统；
- 它的执行操作是异步的，以免阻塞应用程序；

## 1.4 Cookie和Session的区别

二者都是为了解决HTTP的无状态而产生的；
Cookie是保存在客户端的，而Session是保存在服务端的；

## 1.5 Cookie和Storage的区别

Cookie会在发送网络请求时通过请求头发送给服务器，而Storage只会保存在本地；
Cookie可以被客户端和服务端进行修改，而Storage只能被客户端进行修改；
Cookie支持的最大容量为4Kb，而Storage支持最大容量为5M；
Cookie如果没有设置过期时间，就只在当前会话有效期内有效，这一点和sessionStorage相似，但是localStorage在清除之前永久存在；
Cookie如果设置了过期时间，就会在时间有效期内有效，而Storage对象则依旧保持会话有效期/永久生效；

# 2. 浏览器缓存机制

## 2.1 何时触发缓存

- 发起请求时，浏览器首先会在缓存中查找请求结果以及 `缓存标识`；
- 接收响应时，浏览器会将请求数据中的的 `缓存标识`和 `请求结果`进行缓存；

## 2.2 缓存策略

缓存策略分为强缓存和协商缓存；

### 2.2.1 强缓存

强缓存有两种标识，

- HTTP1.0时代的expires，
- HTTP1.1时代的Cache-Control。
- 如果响应头既有expires又有cache-control，那么cache-control的优先级更高。

---

- expires的值是 `服务端的时间`，它是一个具体的时间。一般拿本机时间和该时间做对比判断是否命中强缓存
  所以说如果我们修改了本机时间， 可能会造成强缓存失效。

---

Cache-Control 一般用其中的max-age属性来判断 `是否命中强缓存`，它的值是一个具体的秒数，

- max-age: 单位为秒，表示资源能够被缓存多久。这个时间是从请求成功的时间开始计算的。
- s-maxage: 与 max-age 类似，但只适用于共享缓存（如代理服务器）。当使用 s-maxage 时，共享缓存会忽略 Expires 和 max-age 的值。
- public: 表示响应可以被任何中间缓存存储，即客户端和代理服务器都可以缓存该响应。
- private: 表示响应是为单个用户准备的，只能被客户端缓存，不能被代理服务器缓存。如果设置了 private，s-maxage 指令会被忽略。
- no-cache: 在请求头中出现时，表示即使缓存资源未过期，也必须向服务器请求验证资源的有效性，强制使用协商缓存。在响应头中出现时，表示缓存在提供响应之前必须先向源服务器验证资源是否被修改。
- no-store: 表示不应缓存请求或响应的任何部分。这用于传输敏感数据，以确保不会存储在任何形式的缓存中。
- must-revalidate: 表示一旦缓存过期，缓存必须向服务器请求重新验证资源的有效性，而不能使用过时的缓存。

### 2.2.2 协商缓存

协商缓存有两个版本的请求头和响应头，

- 在HTTP1.0时，响应头为Last-Modified，请求头为Last-Modified-Since，
- 在HTTP1.1时，响应头为ETag，请求头为If-None-Match。

---

- ETag的精确度要高于Last-Modified，

```plain
因为ETag的值是根据文件内容计算出来的哈希值，而Last-Modified仅仅是一个时间，特殊的一些情况下，通过Last-Modified去判断并不准确，比如它的单位是秒，如果1s内修改多次，就会造成数据不一致的情况，又或者是仅仅编辑了文件，并未真正修改，但此时Last-Modified的值会变，这时候明明可以使用协商缓存，也不会使用了；
```

- 性能上Last-Modified要好，也是因为它只是一个时间，并不需要根据文件内容去计算；

## 2.3 发起请求时缓存的详细过程

浏览器第一次加载资源，缓存中没有任何内容，直接正常发起请求，服务器除了返回资源文件以外，还会给response header添加该资源的ETag（如果不支持http1.1，则是最后一次修改的时间Last-Modified），浏览器把资源文件和response header及该请求的返回时间一并缓存；

下一次加载这个资源时，浏览器会先查看请求这个资源的响应头，如果发现这个请求支持强缓存，那么就通过比较这次发起请求的时间和上一次返回数据成功的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件 （如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果未命中强缓存，则看这个请求是否支持协商缓存，如果支持，就在请求头添加If-None—Match（值为响应头中的ETag） (如果不支持http1.1的话，就添加If-Modified-Since，值为响应头的Last-Modified)，然后向服务器发送请求；

服务器收到请求后，根据 ETag 的值判断被请求的文件有没有做修改，ETag 值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的ETag并返回；（如果不支持ETag，就会使用请求头的If-Modified-Since和该文件最后一次在服务器修改的时间进行对比，如果一致，则命中协商缓存，不一致就返回新的数据和Last-Modified。）

## 2.4 缓存的位置

- Service Worker；
- Memory Cache：内存中的缓存；
- Disk Cache：磁盘中的缓存；
- Push Cache：（推送缓存）是 HTTP/2 中的内容；

浏览器会先查看Service Worker，然后去内存缓存查找缓存，然后去磁盘缓存，以此类推...

## 2.5 启发式缓存

   如果响应头没有任何强缓存相关的属性，但是有Last—Modified属性，那么浏览器默认会采用一个启发式缓存。
   该缓存通过公式计算出一个时间，在这个时间内，使用强缓存，公式为Last-Modified Time - Date * 0.1 (10%)。

# 3. Service Worker

## 3.1 概念

Service worker 基于Web Worker，只是比Web Worker多了离线缓存的功能；
本质上充当 Web 应用程序、浏览器与网络（可用时）之间的代理服务器。

- 这个 API 的目的在创建有效的 `离线体验`，它会拦截网络请求并根据网络是否可用来采取适当的动作、更新来自服务器的的资源。
- 它还提供入口以推送通知和访问后台同步 API。
- 出于安全考量，Service worker 只能由 HTTPS 承载;

## 3.2 生命周期

- 注册（register）：如果注册成功，那么Service Worker将会被下载到客户端；
- 安装（install）：安装分为两种情况，
  -- 1. 首次启用Service Worker：

首次启用就会直接尝试安装，安装完成后就会直接进入下个生命周期激活；

-- 2. 之前已经存在激活的Service Worker：

如果现有 service worker 已启用，新版本会在后台安装，但仍不会被激活——这个时序称为 worker in waiting；
直到所有已加载的页面不再使用旧的 Service Worker（使用旧的Service Worker的页面全部被关闭掉）， 才会激活新的 Service Worker；
可以调用skipWaiting()方法，直接激活新的Service Worker，后续所有页面都将被新的Service Worker接管；

- 激活（activate）：service worker 将立即控制页面，但是只会控制那些在 register() 成功后打开的页面。

## 3.3 如何访问Service Worker页面的缓存数据

- 浏览器打开一个页面；
- 为当前页面打开一个新的进程；
- 主线程执行当前页面的任务；
- 如果没有碰到Service Worker，则不进行任何处理；
- 如果碰到了Service Worker，则开启一个Service Worker线程，并记录下当前页面的URL；
- 下次再访问这个URL，会自动打开Service Worker线程，然后访问缓存数据；
