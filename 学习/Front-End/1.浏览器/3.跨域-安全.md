# 1. 浏览器跨域

## 1.1 产生跨域的原因

之所以产生跨域，是因为浏览器的同源策略，即浏览器规定必须协议、ip地址、端口号保持一致时，才算同源。

## 1.2 同源策略限制行为

- 不能发送网络请求；
- 不能获取或操作dom；
- 不能获取本地存储，如cookie、storage、IndexedDB等；

## 1.3 如何解决跨域

- 跨域资源共享（CORS）
- jsonp
- nginx反向代理
- postMessage跨域
- 设置代理服务器

# 1.3.1 CORS解决跨域

跨源资源共享（CORS，或通俗地译为跨域资源共享）是一个基于 HTTP 头的机制，该机制通过允许服务器标记除了它自己之外的其他来源（域、协议或端口），使得浏览器允许这些源访问加载自己的资源。跨源资源共享还通过一种机制来检查服务器是否会允许发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的“预检”请求。在预检中，浏览器发送的头中标明有HTTP器方法而真实请求中会用到的头。

当我们跨域进行发起请求时，如果是简单请求，浏览器就不会进行预检（option）请求，如果是一个复杂请求，就会先发出预检请求；
预检请求会根据服务端的响应头中的Access-Control-Allow-origin来判断是否支持跨域，如果支持则正常发送请求，不支持则在控制台报错；
这种方法主要由服务端进行配置，前端无需关注太多；

# 1.3.2 jsonp进行跨域

jsonp的原理就是利用了script标签不受浏览器同源策略的限制，然后和后端一起配合来解决跨域问题的。
具体的实现方式如下：

在客户端创建一个script标签，
把需要请求的接口地址拼接一个回调函数名称作为参数传给服务端，作为script标签的src属性，然后把script标签添加到body中；
当服务端接收到客户端的请求时，会解析得到回调函数名称，然后把数据和回调函数名称拼接成函数调用的形式返回给客户端；
客户端拿到该数据之后，进行解析，然后调用该回调函数，在回调函数中就可以拿到服务端返回的数据；

# 1.3.3 nginx反向代理

通过配置nginx文件，把客户端发起的请求代理到真实的服务器地址，然后将服务器返回的数据交给客户端；
postMessage跨域
MDN对postMessage的介绍

# 1.3.4 postMessage

 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议，端口号，以及主机设置为相同的值) 时，这两个脚本才能相互通信。window.postMessage()  方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。

在两个窗口之间，通过window.postMessage()发送消息和数据；
通过window.onmessage来接收postMessage发出的消息和数据；
可以利用该功能使用window.open()打开窗口，然后通过postMessage实现浏览器跨页签通信；

# 1.3.5 代理服务器跨域

主要是利用了服务器请求服务器不受浏览器同源策略的限制实现的，但是本地和代理服务器之前也会存在跨域问题，只是说如果我们自己有能力搭建代理服务器，我们就可以自己搭建代理服务器，然后实现本地和代理服务器之间的跨域请求，再通过代理服务器和真实服务器之间的请求拿到最终数据，不必再麻烦自己的服务端同事（求人不如求己）。

# 2. 浏览器的安全性

## 2.1 XSS攻击

XSS攻击就是跨站脚本攻击，指那些通过在HTML文档中嵌入js脚本的方式，从而获取到用户的私密信息的操作

### 2.1.1 XSS种类

- 存储型：一般指一些输入框没有做js脚本的校验，导致黑客输入了一些恶意脚本，然后上传至服务器，然后客户端拿到这些数据又进行了执行；
- 反射型：一般指将恶意脚本作为网络请求的参数发送给服务器，服务器解析之后拼接到HTML文档中发送给客户端，客户端进行执行了这些恶意脚本；
- 文档型：比如一些由用户手动输入然后生成DOM的网站，攻击者将恶意脚本注入到页面中，用户输入内容时，恶意脚本篡改内容，最终执行了恶意脚本，达到了攻击的效果。

### 2.1.2 如何防止XSS攻击

- 严格校验用户输入内容，过滤一些可能发生风险的输入内容，对一些有特殊含义的字符进行转义；
- 利用HttpOnly，不允许通过浏览器访问cooike，以阻止XSS攻击窃取cookie中的敏感信息；
- 使用CSP（浏览器安全策略）：只允许当前页面加载指定的外部资源，可以通过设置http header中的Content-Security-Policy或者meta标签中的http-equiv属性。

## 2.2 CSRF

CSRF就是跨站请求伪造，黑客诱导用户点击链接进入第三方站点，然后通过用户的cookie信息发起而已请求；

### 2.2.1 如何防止CSRF攻击

- 设置samesite：通过设置cookie的samesite属性，阻止向第三方站点携带cookie信息；
- 服务端验证额外信息：比如可以给客户端token，然后每次发起请求时让客户端携带token；
- 阻止第三方页面发起请求：可以让服务端阻止第三方网站请求接口；

## 2.3 点击劫持

点击劫持是一种视觉欺骗手段，攻击者将被攻击者的网站通过iframe嵌入到自己的网页中，并且将iframe设置透明，然后放出一个按钮诱导用户点击；

### 2.3.1 如何预防点击劫持

使用 HTTP的一个响应头 X-FRAME-OPTIONS，防御用iframe 嵌套的点击劫持攻击。
该响应头有三个值可选

- DENY，表示页面不允许通过 iframe 的方式展示
- SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示
- ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示

## 2.4 SQL注入

SQL注入就是利用前端输入框校验漏洞以及后端SQL语句漏洞达到攻击目的
比如攻击者可以在输入框输入SQL命令，然后发送给服务端，
服务端将SQL命令作为前端参数进行解析执行，可能会执行一些非自己意愿的SQL语句。

### 2.4.1 如何预防SQL注入

- 严格校验 输入框内容，将一些特殊含义的字符进行过滤；
- 服务端对前端参数也要严格进行校验，防止一些非法参数的混入；

## 2.5 XSS和CSRF以及SQL注入的区别

XSS和SQL注入都是因为校验问题产生的漏洞，不过前者是前端执行恶意脚本，导致用户信息泄露产生的，而后者是因为后端执行恶意SQL而产生的漏洞；
XSS是通过先获取到用户的信息再进行攻击，而CSRF则无需获取用户信息，直接利用http携带cookie的特性，直接发起攻击，而不知道cookie中的具体内容；
XSS是执行了恶意脚本，才导致的被攻击，而CSRF无需执行恶意脚本，只是利用http本身的漏洞和开发者配置的漏洞进行的攻击；
