# 1. 进程和线程

进程是cpu资源分配的最小单位；
线程是cpu调度的最小单位；

## 1.1 进程和线程的关系

- 通俗来讲，每一个执行中的程序就可以称之为进程，而一个进程由多个线程组成；
- 一个进程中任意一个线程出错，就会导致整个进程出错；
- 一个进程中的所有线程共享进程中的数据；
- 不同进程之间的内容相互隔离；
- 关闭进程时，进程中的所有线程也会被关闭；

## 1.2 浏览器的进程和线程

现在许多浏览器采用的是多进程、多线程的架构模式，比如chrome，就是一个多进程并且多线程架构的浏览器。
多线程架构的浏览器，打开的每个Tab是一个线程，而多进程的浏览器，打开的每一个Tab，都是一个进程。
多进程浏览器的优势

我们打开的每个tab页，即使卡顿、崩溃，也只是那一个进程会受到影响，其他进程不会受到影响；
现在很多cpu都是多核的，而多进程可以完美的发挥cpu的优势；
浏览器中还有插件进程，同时也保证了不同插件发生崩溃时不会影响到浏览器的使用；

## 1.2. 浏览器内核

浏览器内核是属于多进程浏览器的其中一个进程，也被称为渲染进程，它拥有多个线程。

### 1.2.1 主流浏览器的内核

- chrome使用blink内核，之前使用的是由Chromium内核（fork自webkit）；
- safari使用的是webkit内核，是webkit的鼻祖；
- firefox使用的是Gecko内核；
- IE/Edge使用的是Trident内核；
- Opera使用的是blink内核（因为是和谷歌一起研发的）；

### 1.2.2 浏览器内核中的线程

渲染进程中一般由以下几种线程组成：

- GUI渲染线程
- JavaScript引擎线程
- 定时器触发线程
- 事件触发线程
- 异步http请求线程

### 1.2.3 JS是单线程还是多线程

js是单线程的，原因是因为js最初的使用场景最多的就是与用户的交互，这就离不开dom的操作，只有单线程，才能保证同一时间，用户只能操作一种功能，如果是多线程，就会造成很多问题。

## 1.3 Web Worker

Web Worker 是一种在浏览器中运行 JavaScript 代码的机制，它允许开发者在后台线程上运行脚本，从而不会影响页面的性能

### 1.3.1 好处

可以在独立线程中执行费时的处理任务，使主线程（通常是 UI 线程）的运行不会被阻塞/放慢。

Web Worker是浏览器为JavaScript创建的一个多线程环境，但它并不代表js是多线程的。
在Web Worker中是不能操作dom的，这是因为我们通过new Worker()创建一个Worker时，
虽然浏览器单独开辟出来了一个新的线程，但是当前线程只是帮助我们运行一些复杂、耗时的任务，它还是受主线程控制的，
因此，严格意义上来说，js是单线程这一点，从未改变过。

### 1.3.2 限制

- 同源限制：worker中运行的脚本文件，必须和主线程的脚本文件同源；
- 文件限制：worker不能加载本地文件，必须是网络文件；
- 不能操作DOM：不能直接操作dom对象，只能通过和主线程传递消息，由主线程操作dom；
- 语法限制：某些函数或者类不能在worker中使用；可以使用的参考这个
- 通信限制：不能和主线程直接通信，需要使用postMessage方法进行通信；
## 1.4 死锁
### 1.4.1 死锁原因：
 当线程1持有锁2，正在请求另一个锁1；线程2持有锁1，接着请求获得锁2。这个时候死锁就产生了。
通过上面例子可知，加锁顺序的不一致是死锁的诱因。再说通俗一点就是两个线程都在等待对方持有的锁资源被释放，都在互相等待你的资源，干瞪眼了。这就是我对死锁产生原因的理解。
4点缺一不可
- 互斥：线程对于需要的资源进行互斥的访问（例如线程获得一个锁）
- 持有并等待：线程持有了资源，同时又在等待其他资源（例如需要获得一个锁）
- 非抢占：线程获得资源（例如锁），不能被抢占
- 循环等待：线程之间存在一个环路，环路上每个线程都额外持有一个资源，而这个资源又是下一个线程要申请的。（就是加锁顺序）
### 1.4.2 避免死锁
- 保证加锁顺序一致：目的就是让代码不会产生循环等待
- 适当避免互斥操作：让整个操作无锁化，通过强大的硬件指令，CAS可以构建各种原子操作，无锁数据结构。例如Java的Atomic包，著名无锁队列Disruptor。

- 银行家算法---通过调度避免死锁
首先要明白一个道理，死锁是建立多核cpu上。单核CPU是不会发生死锁的。

参考如下，因为线程1，2不存在并发执行，即使两个线程加锁顺序不一致，也不会导致死锁
# 2. 浏览器渲染

## 2.1 渲染流程

- 1. 从上到下解析HTML，生成 `DOM树`；
     （如果遇到不带async或defer的js脚本，会阻塞HTML的**解析**;
     如果是带async的js脚本，在加载js脚本时不会阻塞，但是在执行时会阻塞）；
- 2. 解析CSS资源，生成 `CSSOM树`；
     （CSS的解析不会阻塞HTML的解析，因为CSS的解析是在预解析线程执行，而HTML的解析是在主线程执行，但是会阻塞HTML的渲染）；
- 3. 将解析好的CSS合并到主线程，将CSSOM树和DOM树合并，构建 `渲染树`（Render）；

---

- 4. 计算：依次计算DOM树中每个节点的样式，得到最终样式；
- 5. 布局：将DOM树中的每个节点进行布局，得到 `布局树`；
- 6. 分层：浏览器会根据布局树，对整个页面进行分层，后续哪些节点有改动，只需要改动某一层的信息，层叠上下文或者CSS属性的will-change都会影响浏览器的分层；
- 7. 绘制：浏览器发出绘制指令，交给分层之后的每一层进行绘制，至此，主线程工作结束，剩下的交由合成线程进行处理；
- 8. 分块：合成线程从线程池中调度更多的线程对每个图层进行分块，将他们分成更小的区域；
- 9. 光栅化：分好块之后，合成现场将分好的块交由GPU线程，GPU会以极快的速度完成光栅化，为了使页面更快的展现出内容，会优先处理靠近视口位置的块；
- 10. 画：完成光栅化之后，每个块就变成了一块一块的位图，然后交由合成线程，合成线程将每一块位图画到屏幕相应的位置，并查看是否有缩放、旋转等操作，而transform就是在这一步完成的，这也是为什么transform性能要更好的原因。最终由浏览器主线程完成最终的展示。

## 2.2 网页文档的加载

### 2.2.1 加载状态

document.readystate 它的值可以是以下三种之一：

- loading(正在加载)
- interactive(可交互)
- complete(完成)

### 2.2.2 DOMContentLoaded

- 相当于document.readystate的interactive（可交互）；
- 当 HTML 文档完全解析，且所有延迟脚本下载和执行完毕后，会触发 DOMContentLoaded 事件；
- 它不会等待图片、子框架和异步脚本等其他内容完成加载；

### 2.2.3 window.onload

- 相当于document.readystate的complete(完成)；
- load事件在整个页面及所有依赖资源如样式表和图片都已完成加载时触发。
- 它与 DOMContentLoaded 不同，后者只要页面 DOM 加载完成就触发，无需等待依赖资源的加载。

### 2.2.4 网页文档的加载执行过程

- 浏览器开始解析HTML，此时document.readystate为loading；
- 解析中遇到不带async和defer的script脚本时，需要等待 script脚本 下载完成并执行后，才会继续解析 HTML；
- 遇到带defer的script脚本，等待它们下载完毕，这些脚本会在HTML解析之后开始执行，等待它们执行完毕；
- 当 HTML 文档完全解析，且所有延迟脚本下载和执行完毕，document.readyState变成 interactive，触发 DOMContentLoaded事件;
- 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行（如 `<script async src=xxx >`），document.readyState变为 complete，window 触发 load 事件;

## 2.3 阻塞关系

### 2.3.1 说一下js文件、css文件、html、图片资源之间的阻塞关系

CSS的解析和HTML的解析没有阻塞关系，因为二者在不同的线程完成，CSS的解析在预解析线程，HTML的解析在主线程；
CSS的解析会阻塞HTML的渲染，因为HTML的渲染需要CSS样式，如果CSS没有解析完毕，HTML无法完成渲染；
不带async或者defer的script标签会阻塞HTML的解析，并且会等待执行完毕之后才会继续解析HTML；
带async的script标签在下载时不会影响HTML的解析，因为是在不同的线程进行下载，但是下载完毕之后会立即执行，执行会阻塞HTML的解析；
带defer的script标签，不会影响HTML的解析，因为它在不同的线程进行下载，并且它会等待HTML解析完毕再进行执行；
CSS的解析和js的下载不会有任何阻塞关系，因为它们在不同的线程，但是会影响js的执行，因为js可能会操作dom修改css，所以说必须等待css加载完毕，才能继续执行js；
图片资源的加载，不会和任何产生冲突，因为它会在其它线程进行异步下载；

### 2.3.2 CSS为什么最好要放在头部

    首先CSS不会阻塞HTML的解析，所以放头部和尾部没太大影响，但是CSS会阻塞HTML的渲染，如果把CSS放在尾部，HTML解析完毕了，过了一会CSS又解析完毕了，浏览器又要根据CSSOM树重新计算HTML节点的样式，重新进行布局，可能会造成回流等现象。

### 2.3.3 js文件为什么放到尾部比较好

    因为js文件会阻塞HTML的解析，如果放在头部，js文件过大时，会导致HTML解析长时间无法完成，DOM树无法构建，页面无法渲染，造成长时间白屏的现象，影响用户体验。

## 2.4 回流和重绘

### 2.4.1 回流

    回流又称重排，它指的是我们修改或者访问了一些HTML元素的几何信息，比如宽高等，当我们操作了这些之后，浏览器就需要重新计算每一个元素的布局位置等，重新生成布局树，然后进行分层分块光栅化等一系列操作，频繁的操作会引起页面的卡顿，影响页面性能。

### 2.4.2 重绘

    重绘指的是没有修改元素的几何信息，只是修改了外观，例如背景颜色、字体颜色等，这些操作不会引起浏览器重新计算布局，但是需要浏览器重新进行绘制操作，相对于回流来说，性能会稍好一些。

### 2.4.3 如何减少回流/重绘的产生

- 操作dom修改样式时，尽量修改元素的class代替修改元素的style，将多个style在一个class中完成；
- 将一些复杂的动画效果运用到position为fixed或者absolute的元素上，这些元素会脱离文档流，不会影响其他元素的布局；
- 对DOM进行离线处理，在对DOM进行多次影响布局的操作时，可以先将DOM的display设置为none，然后处理完毕再进行展示，就会在一次回流中处理完毕；
- 利用GPU加速，也就是多采用transform代替left、right等操作，因为transform是在浏览器渲染的最后一步交由GPU硬件来进行绘制的，性能会更好，也不会引起回流重绘，此外opacity、filters也是；

## 2.5 DOM和BOM

DOM就是我们HTML文档解析完毕，由各个节点组成的DOM树；
BOM就是Browser Object Model，也就是我们的浏览器对象，比如window对象，document对象，以及这些对象上的一些方法，都属于BOM；
DOM和BOM并不是同一个东西，在我们的开发中，通常我们操作DOM去访问文档内容，然后通过BOM去操作我们浏览器的一些功能，二者相辅相成，缺一不可；

# 3. V8引擎

## 3.1 V8引擎是什么

V8是由C++编写的JavaScript 和 WebAssembly 引擎，也正是有了V8，chrome浏览器才会在众多浏览器中脱颖而出；
V8可以独立运行，也可以嵌入到任何C++应用程序中，Node.js就是基于V8引擎的；

## 3.2 V8引擎对js代码的处理流程

- V8 引擎解析 JavaScript 代码时，首先会将代码通过Parser进行词法分析和语法分析解析为AST抽象语法树(一个查看 AST 语法树的网站)，vue 中的template以及babel都使用了AST抽象语法树；
- 然后会通过Ignition是一个解释器，将AST抽象语法树转化为字节码，同时会帮助Turbofan收集一些优化所需要的信息（比如函数的参数类型信息，函数的调用次数等）；
- 之后将字节码转化为机器码被计算机识别并执行，（为什么不直接转化为机器可以识别的机器码呢？因为不同的机器拥有不同的 CPU，不同架构的 CPU 所支持的机器指令不同，因此不能直接转化为机器指令，而是逐步转换）；
- Turbofan是一个编译器，一些高频的代码，它会对其进行标记（hot），把这些代码的机器指令保存下来，再次执行时，无需转换字节码，可直接执行机器指令，这也是 V8 引擎快速的原因之一；
- 在执行Turbofan中保存的函数时，如果函数参数类型发生改变，函数的执行流程可能有所不同，因此会通过deoptimization进行反向优化, 把机器码重新转化成字节码再次进行编译运行；

## 3.3 JavaScript中的内存管理

- 在JavaScript中，如果是基本数据类型，V8会帮助我们在栈空间分配内存；
- 如果是复杂数据类型，会帮助我们在堆空间分配内存，并将对该变量的引用指向该块堆空间，但是该块空间的内存地址，存在栈空间中；
- 访问一个对象时，会先去栈空间找它的引用地址，然后再去堆空间找到数据；

（3）垃圾回收

因为内存空间大小是有限的，因此一些数据如果在不使用的时候不进行回收或销毁，就会一直占用内存，如果数据太多，就会出现栈溢出的报错，因此，当一些数据不再需要时，我们应对其进行回收，垃圾回收器（Garbage Collection）也称作GC。

（4）常见的垃圾回收算法

- 引用计数：当一个变量被引用时，内部就会记录它的引用次数，当引用次数为0时，就会被垃圾回收器回收掉；它的弊端也很明显，如果两个变量相互引用，那么计数就永远不会是0，内存就永远不会被回收，造成内存泄漏问题；
- 标记清除：设置一个根对象（Root Object），垃圾回收器会定期从根对象开始查找，如果某些对象没有被引用到，就会把这些对象进行垃圾回收，该算法可以很好的解决循环引用问题，大多数js引擎采用该方法，而V8为了更好的优化，还搭配了一些其他算法使用；

（5）V8引擎中的垃圾回收
栈内存的回收
在js中，由于js是单线程的，每次执行函数的过程就是一个压栈的过程，在V8中，每次执行一个函数时，就会有一个ESP指针指向当前正在执行的上下文，当执行完毕时，指针就会向下移动，上一个执行上下文的内存就会被回收，局部活动对象也就会随之销毁。
堆内存的回收

V8引擎对于堆内存中的变量，将它们分为了两种，分别是新生代和老生代；
新生代指的就是那些存活时间比较短的对象，这个区域大小通常大小在1~8M左右；
老生代指的就是那些存活时间比较长的对象，这个区域容量相对比较大；
V8为新生代和老生代又使用了了两个主要的垃圾回收器，分别是副垃圾回收器，负责新生代区域的垃圾回收，以及主垃圾回收器，负责老生代区域的垃圾回收；

新生代垃圾回收策略

新生代采用Scavenge算法对新生代区域分区，分成使用区（From）和空闲区（to）；
当创建一个新的对象时，会先被分配到使用区；
当使用区空间到达阈值后，会进行垃圾回收，垃圾回收器对使用区的活跃对象进行标记，然后把标记过的对象复制到空闲区，然后清除使用区，然后再将空闲区和使用区进行交换；
当一个对象多次复制且依旧存活时，就会被认为是一个存活时间较长的对象，于是就会从新生代转移到老生代（当从使用区复制一个对象至空闲区时，如果空闲区的使用空间超过25%，那么该对象就不会被复制到空闲区，而是直接转移到老生代，如过不这么操作，比如所有使用区的对象都处于活跃状态，全都转移到了空闲区，然后又全都转移到了使用区，这时，如果新增一个活跃对象，使用区就没有它的存储位置了）；

老生代垃圾回收策略

老生代采用了标记清除和标记整理两种算法；
标记清除就是定期从根节点查找那些没有活跃的变量，进行清除，但是这种清除方法会出现内存碎片现象；
标记整理就是为了解决标记清除之后产生的内存碎片化现象；

内存碎片化现象指的就是，不同的变量它们在内存中的位置可能是断断续续的，我们
在回收它们的时候，空出来的空间也变成了断断续续的，这时如果老生代新进入了一个占用内存较大的对象，我们发现这些空闲出来的空间都不够插入的，直到找到有足够空间的位置才行，就会造成许多不必要的查找，而标记整理就是在我们回收掉这些对象之后，把这些空闲空间由后面的变量挤占过去，那就形成了一部分空间都是完美利用的，另一部分都是空闲出来的。

其他垃圾回收的优化
并行回收和增量标记

由于js是单线程的，而垃圾回收也由主线程去完成，如果垃圾回收时间较长，就会阻塞js脚本运行，导致系统停顿，等待垃圾回收完成之后，才能恢复正常，这种现象称为全停顿。

为了解决这种现象，V8引擎首先加入了并行回收的策略，也就是在进行垃圾回收时，会开启多个辅助线程进行协助处理，缩短了垃圾回收的时间，但是在处理老生代垃圾回收时，效果依旧不是特别理想，于是又提出了增量标记的策略进行优化（采用三色标记法），主要有以下几个步骤：

初始标记：在初始节点，V8引擎会从根对象出发，依次遍历能由根对象直接可达的对象，并将它们标记为活跃对象，此时会阻塞脚本的执行；
并发标记：在标记出活跃对象之后，V8会启动辅助线程，异步遍历其它的对象，并找到活跃的对象，这个阶段不会阻塞脚本执行；
再标记：在辅助线程标记活跃对象的过程中，由于脚本代码还在执行，可能某些对象的引用已经改变了，或者说已经不再活跃了，就需要对并发标记过程中标记的活跃对象再次进行标记，以保证引用的准确性；
开始清除：在增量标记完成之后，V8引擎会开始垃圾回收，回收的过程会使用惰性回收和并发回收；

通过这种方式，V8引擎将一次GC的过程分解成了多步进行，其中有同步又有异步，即能准确高效的清除非活跃对象，又不会长时间阻塞脚本执行。
惰性回收
惰性回收指的是V8引擎最终在执行垃圾回收的时候，如果发现当前内存还够用，那就延迟进行回收，以保证js代码的优先执行，然后再进行清理，清理也不会一次性清理，而是清理一部分，剩余的留在下次GC再进行清除。（说白了就是，只要内存够用就先不清除，先保证代码的流畅运行，找机会再清除。）
并发回收
虽然引入了惰性回收和增量标记，可以使GC的效率大大增强，但是最终在进行回收的时候，还是会引起主线程JS脚本的停顿，为了继续优化这方面，V8引擎又引入了并发回收，也就是说在最终回收阶段，开启辅助线程，帮助主线程进行垃圾回收，这样既完成了垃圾回收，又不会阻塞主线程js脚本的执行。

# 4. 事件传播阶段（事件模型）

事件传播分为三个阶段，顺序依次是捕获 -> 目标 -> 冒泡：

- **（1）捕获阶段**：从window开始，向事件的触发处传播，但是此时不会触发事件，因此到达目标父级，停止；
- **（2）目标阶段**：事件到达目标元素，触发目标事件；
- **（3）冒泡阶段**：然后从目标开始，向上传播，遇到注册的冒泡事件会触发；

## 4.1 事件冒泡

- 在事件传播的过程中，子元素的事件会依次向父级传播，由内向外传播，就称之为事件冒泡；
- 这就会造成，我们明明想触发父元素的事件，但是子元素的事件也同时被触发；

## 4.2 事件捕获

事件传播的过程中，父元素的事件会向子元素传播，由外向内传播，就称之为事件捕获；

## 4.3 如何取消事件冒泡

- IE浏览器可以在处理事件回调函数中添加e.cancelBubble = true来取消事件冒泡；
- 符合W3C标准的浏览器可以在处理事件回调函数中添加e.stopPropagation()来取消事件冒泡；

## 4.4 如何取消默认事件

某些标签拥有默认事件，比如a标签、form表单等，如果我们想阻止这些元素的默认事件，可以通过以下方式进行解决：

- 正常的浏览器可以通过e.preventDefault()；
- IE则需要通过e.returnValue = false；
