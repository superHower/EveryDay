# 1. Vue

Vue是一款基于MVVM架构的渐进式框架，它主要用于构建单页面应用（spa），它的特点有声明式渲染、响应式两大点。

## 1.1 MVVM

MVVM就是Model-View-ViewModel的缩写，它是一种架构模式，是MVC（Model-View-Controller）的改进版。

### 1.1.1 MVVM 定义

- Model：指的就是负责应用的数据处理以及整体业务逻辑（相当于后端）；
- View：指的就是展示给用户的界面（相当于HTML页面）；
- MVVM中的ViewModel：指的就是视图模型，它是View和Module沟通的桥梁，用于展示数据、处理用户交互、并且更新模型，并且视图会与视图模型进行关联，将视图中的一些方法和属性封装在视图模型中，然后通过视图模型和模型之间获取、更新数据，然后将真实的数据反映到视图中。

### 1.1.2 MVVM的架构优点

- 低耦合：视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变；
- 可复用：可以将一个ViewModule的逻辑给多个View使用；
- 独立开发：开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计；
- 可测试：因为ViewModel是独立于界面的，因此测试人员可以专注于业务逻辑，而无需依赖具体的页面实现；

### 1.1.3 双向数据绑定原理（必问）

  通过数据劫持，结合【发布者-订阅者模式】来实现
    在数据发生改变时， 发布消息给订阅者， 触发对应的监听回调渲染视图
    使得数据和视图是同步的

- 原理
  data数据在初始化的时候，会实例化一个Observe类，
  它会将data数据进行递归遍历，并通过Object.defineProperty方法，给每个值添加上一个getter和一个setter。

  在数据【读取】时， 触发getter进行依赖（Watcher）收集，
  当数据【改变】时， 触发setter，对刚刚收集的依赖进行触发，
  并且更新watcher通知视图进行渲染。

## 1.2 什么是渐进式框架

### 1.2.1 渐进式框架概念

- 使用渐进式框架时，无需引入其所有功能，而是需要什么就用什么
- 就拿Vue来说，我们可以引入一个vue.js的文件，然后在其它框架中去使用Vue，
- 也可以使用它的脚手架，来进行构建一个Vue项目，

### 1.2.2 渐进式框架的优点

- 灵活：开发者可以按需引入框架的各个功能；
- 可维护性：开发者可以先少量引入框架部分功能，然后在需要的时候引入其它功能，防止项目从一开始就变得结构复杂、难以维护。

## 1.3 SPA页面

- SPA就是单页面应用，这是一种网站的设计模式，
- SPA就是一个网站中，只有一个HTML文件，
- 用户在进行页面交互时，或者刷新页面时，只是利用JavaScript动态变换HTML的内容，而并非真正意义上的变换页面。

### 1.3.1 SPA优点：

- 交互体验好：因为用户在交互时，只是动态刷新局部内容，并不用请求新的HTML文件，因此也就不会造成长时间的页面白屏；
- 工作模式好：更好的实现前后端分离，让不同岗位的工程师专注于自己的领域，提升代码的性能以及复用性；
- 路由：使用前端路由，通过浏览器的API来模拟前进后退操作，让用户在使用感知上并无变化。

### 1.3.2 SPA缺点：

- 首页开销大：因为所有的资源都需要在首页进行加载，因此资源过多时会产生白屏问题；
- 内存占用较大：在SPA中，一旦页面加载完成，所有的页面内容和状态都保存在内存中，如果页面过于复杂或用户长时间停留在页面上，可能导致内存占用较大，影响设备性能；
- 不利于SEO：SPA页面在初始化时只有HTML的基本骨架，其它内容需要依赖于JavaScript的异步加载，浏览器不能完整的捕获到页面内容，不利于SEO。

## 1.4 什么是声明式渲染

- 声明式渲染，就是你只需要告诉框架你的目的，至于它内部如何达成你的目的，你无需关心。
- 命令式渲染，你需要一步步操作，让框架执行你的操作，最终达成你的目的。


# 2. computed 与 watch

## 2.1 computed

作用：根据data数据的数据对象做计算处理
原理：computed在Vue内部做了缓存处理，
            只有它的依赖属性发生了变化，它才会重新计算并且触发渲染。
使用：当模板中的某个值需要通过[一个或多个数据计算]得到时

```js
    computed: {
      // 简写法
      totalCount () {
        return this.list.reduce((sum, item) => sum + item.num, 0)
      },
      // 完整写法 → 获取 + 设置
      fullName: {
        get () {
          return this.firstName
        },
        set (value) {

        }

      }
    }
```

## 2.2 watch侦听器

作用：对依赖属性进行监听。
原理：当侦听的属性发生变化时，就会执行一个函数。
            watch是异步函数，当属性需要在侦听后再执行某个变化,可以使用$nextTick这个API
使用：当监听某个值[发生变化]后，对新值去进行逻辑处理。

---

v-model=“obj.lang” 中写入要监视的对象的属性

```js
watch: {
      obj: {
        deep:true,       // 深度监视， 对obj对象的所有属性进行监视
        immediate: true, // 立刻执行
        handler (newValue) {
          console.log(newValue)   // newVale监视的所有值
          // 进行监视
        }
      }
    }
```

# 3.常见问题

## 3.1 computed 与 watch区别

* `computed`是有缓存的，读取computed属性时，如果 `依赖的值没有变化`，就会读取缓存的内容，而 `watch`没有缓存，只要数据改动，就会触发回调；
* `computed`必须要有返回值，`watch`不需要有返回值；
* `computed`在初始化时就会执行一次，而 `watch`初始化时默认 `不会执行`，如果我们想让它执行，可以设置它的 `immediate`属性为 `true`；
* `computed`相当于创建了一个新的 `响应式属性`，而 `watch`相当于监听 `原有的响应式属性`，然后执行回调；
* `computed`中处理的是 `同步操作`，而 `watch`可以处理 `异步任务`。

## 3.2 data为什么必须是一个函数

`data`是一个组件的 `私有属性`，但是 `一个组件`可以被 `其它多个组件`使用，之所以必须是一个函数，是因为函数作用域是 `私有作用域`，保证变量不会被污染。如果我们返回一个 `普通对象`，在多个组件使用该组件时，如果都对data中的某个属性进行了修改，`所有使用该组件的组件`都会被影响，而使用函数则每次都会创建一个新的对象，保证当前的data不会被其它组件所影响。

在每一次创建 `组件实例`时，Vue都会去初始化这个组件的状态。

* 查看组件有没有data属性；
* 如果有data属性，会查看data `是不是一个函数`，如果是函数，就直接调用这个函数，并将函数返回的对象 `赋值给组件实例的data属性`（这就是为什么使用函数不会造成变量污染，因为每次都会调用这个函数，生成新的对象）；
* 如果不是函数，会看之前组件实例上的data是不是空值，如果不是，就用之前的，如果是就赋值一个空对象（这就是为什么直接写成对象会造成变量污染，因为每次创建组件实例时都会使用之前的data）。
* Vue内部也帮我们做了 `异常处理`，当我们的 `data不是一个函数`时，会 `抛出异常`。

## 3.3 data 和 props 的区别？

    props: 将父组件的数据向下传递到子组件的方式。只读无法修改
    data : 组件自己的数据，仅供自身使用，可以修改。数据是响应式的。

## 3.4 v-if和v-for谁的优先级更高

在 `Vue2`中，v-for的优先级要 `高于`v-if，但是在 `Vue3`中，v-for的优先级要 `低于`v-if。

在 `Vue2`中，会先通过 `v-for`遍历，然后对每一项使用 `v-if`判断，不满足条件的不会渲染，但是这种方式并不好，相当于对很多个标签都添加了 `v-if`，每次渲染之前都要判断。于是在 `Vue3`中，`v-if`的优先级要 `高于v-for`了，相当于在 `v-for外层包裹了一层`，但是这时的判断条件肯定是错的，因此在 `vue3中`同一标签使用 `v-for和v-if`时，会报错。

```html
<div v-if="item === 1" v-for="item in 6" :key="index">
    <span>{{ item }}</span>
</div>

<!-- 等价于 -->
<template v-if="item === 1" > <!-- 此时肯定会报错 -->
    <div v-for="item in 6" :key="index">
        <span>{{ item }}</span>
    </div>
</template>
```

## 3.5 v-for的key是做什么的

`key`的作用就是标识当前 `VNode节点`，一般用于 `v-for`中。使用 `key`进行标识的元素，在进行 `更新`操作时会将 `更新前后两个key相同的元素`视作同一元素，进行对比，然后进行相应的更新操作，如果没有 `key`，就只能按 `顺序`进行对比，在 `合理的场景使用合理的key`可以提升 `更新时的渲染性能`。

## 3.6 为什么不建议使用index作为v-for的key

比如说有以下代码：

```html

<template>
  <div class="wrap">
    <span v-for="(item, index) in arr" :key="index">{{ item }}</span>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'

const arr = ref([1, 2, 3, 4, 5])

onMounted(() => {
  arr.value.unshift(0)
})
</script>

```

在第一次渲染时，渲染了5个span标签，它们的key分别为 `0、1、2、3、4`。这时v-for遍历的数组 `头部`插入了一项新的值，页面进行 `更新`，渲染了6个span标签，它们的key变成了 `0、1、2、3、4、5`，虽然新的 `1、2、3、4、5`就是之前的 `0、1、2、3、4`，但是在进行更新时，会拿 `key`相同的去对比，这样一来就变成了 `旧的1和新的1（相当于旧的0）`、`旧的2和新的2（相当于旧的1）`......以此类推，明明本来只是 `新增了一个节点，其它节点都不用改变`，但是现在却变成了 `每个节点都需要更新`，影响了渲染性能。这也是为什么不提倡使用 `索引值index`作为key的原因，因为它 `并没有对更新时的渲染起到任何优化作用`。

# 4. vue指令

```shell
——————————————————————————————————————————————————-
v-show: 控制元素显示与隐藏:  (display的none的控制)：频繁显示和隐藏
v-if , v-else , v-else-if:  (条件控制): 创建和移出元素节点
v-for: v-for=" (item, index) in 数组"
  ## 2. v-for: 中key的值作用是什么？
    key是DOM元素的唯一标识
    - 作用
    1. 提高虚拟DOM的更新， 在更新的时候不改变原来的，只把新来的dom加上
    2. 触发过度效果
________________________________________________
v-html: 解析标签,动态设置内嵌标签
v-bind: 动态设置html的标签属性，绑定元素属性到vue实例的数据 
v-bind:src 可简写成 :src
——————————————————————————————————————————————————
v-model：
    1. 作用在表单: v-bind:value 表单元素双向绑定
                  v-on:input 监听数据变化， 并修改value
    2. 作用在组件：是父子通信语法糖，
                  通过props和$emit 实现 
——————————————————————————————————————————————————
:class="{类名1：bool, 类名2：bool}"  (一个类名，来回切换)
:class="[类名1：bool, 类名2：bool]"  (批量添加或删除类)

————————————————————————————————————————————————————
v-on: 注册事件 = 添加监听       ( v-on:click 可简写成 @click )
@keyup.enter:   键盘回车监听
@click.stop:    阻止冒泡
@click.prevent: 阻止默认行为

__________________________________________________
```

# 5. Vue中常见的修饰符

（1）事件修饰符

.stop：阻止事件冒泡；
.prevent：阻止默认事件；
.self：只有事件在当前元素自身触发时，才会调用函数；
.capture：捕获模式，内部元素的事件在被内部元素处理之前，先被外部元素处理；
.once：该事件只会触发一次；
.passive：一般用于触摸事件的监听器，可以用来改善移动端设备的滚动性能；

（2）按键修饰符

.enter：仅在Enter键时调用；
.page-down：仅在PageDown键时调用；
.tab：仅在tab键时调用；
.delete：仅在delete或Backspace键时调用；
.esc：仅在esc键时调用；
.space：仅在space键时调用；
.up：仅在up键时调用；
.down：仅在down键时调用；
.left：仅在left键时调用；
.right：仅在right键时调用；
.ctrl：仅在ctrl键时调用；
.alt：仅在alt键时调用；
.shift：仅在shift键时调用；
.meta：在Windows上是Win键，在Mac上是Command键，不同机器上键位不同。

（3）鼠标按键修饰符

.left：鼠标左键触发；
.right：鼠标右键触发；
.middle：鼠标中键触发；

.sync修饰符
.sync修饰符是v-bind:xxx和@update:xxx的语法糖，在Vue3中已被移除，使用v-model:xxx替代。
# 6 插槽

## 6.1 插槽的用处

- 创建可复用组件：通过插槽，你可以创建具有灵活内容的组件，而不必硬编码组件的结构。
- 插入自定义内容：父组件可以将自定义内容插入子组件的插槽中。
- 嵌套插槽：可以创建嵌套的插槽结构，以实现更复杂的布局。

## 6.2 插槽的基本用法

- 子组件定义插槽：`<slot>`
- 子组件具名插槽: `<slot name="header"></slot>`

---

- 父组件使用插槽：`<template v-slot:header>`
- 在 Vue 2.6.0+ 中，可用简写形式<template #header>
- 作用域插槽
  插槽还可以是“作用域”的，这意味着插槽的内容可以访问子组件中的数据。这通过将数据作为插槽的一部分传递来实现：

```html
<template>
  <div class="child-component">
    <slot :text="someData"></slot>
  </div>
</template>
在父组件中，你可以像这样使用作用域插槽：

<template>
  <child-component>
    <template v-slot:default="slotProps">
      <div>{{ slotProps.text }}</div>
    </template>
  </child-component>
</template>
在这里，slotProps 是一个对象，包含了子组件传递给插槽的所有数据。
```
