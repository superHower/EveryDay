vue

# vue生命周期（8个）
  组件从创建到销毁的过程
  1. 创建
      [beforeCreat]：创建实例之前。
      [created]：Vue实例创建完毕，
          可以访问data、computed、watch、methods上的方法和数据，可以进行一些简单的Ajax，对页面进行初始化之类的操作
          但还没有将虚拟Dom挂载到真实Dom上，所以此时访问不到Dom元素（el属性，ref属性此时都为空）
  2. 挂载
      [beforeMount] : 会在此时去找到虚拟Dom，并将其编译成Render,【即将】渲染与修改数据， 不会触发updade
      [mounted] : 虚拟Dom已经被挂载到真实Dom上，访问$ref, 做Ajax请求，可以获取Dom节点，对节点做一些操作
  3. 更新
      [beforeUpdate] : 虚拟Dom还没更新，此时依旧可以访问现有的Dom。
      [updated] : Dom已经更新完毕，可以执行一些依赖新Dom的操作。不建议在此时进行数据操作，避免进入死循环
  4. 销毁
      [beforeDestory] : 实例还未被销毁。实例还可以用，如：销毁定时器，解绑全局事件，销毁插件对象等
      [destoried]： 组件已经被销毁
## keep-alive的原理
keep-alive是一个内置的组件，因此它其实和普通组件类似，
只是在keep-alive组件的不同生命周期函数中做了一些特殊的处理，可以缓存我们的组件，
主要是通过created、destroyed、mounted、render四个函数进行处理。
### （1）created阶段
在created阶段，keep-alive组件会创建一个空对象，用于存放需要缓存的组件的信息。
### （2）render阶段
在render阶段，就会拿插槽中的内容，然后获取插槽中的第一个组件，这也是为什么在keep-alive中写多个组件时，只会缓存第一个的原因。
拿到第一个组件之后，就会去获取当前组件的name，然后和include/exclude中的内容匹配，如果判断该组件不需要缓存，就直接返回组件VNode信息，如果需要缓存，就执行下一步操作。
缓存时，会看组件的VNode信息中有没有key，如果没有key，就会根据组件标签（tag）和cid拼接成一个key，然后判断key是否已经存在于缓存中，如果不存在，就将key和当前VNode作为一组数据进行缓存，如果存在，就会把当前VNode的组件实例替换为缓存中当前key的组件实例，最后返回VNode，也就是说当我们访问一个组件时，如果命中了缓存，那么访问的其实就是缓存中上一次该组件的实例信息，并且每次命中缓存时，都会调整该组件在缓存中的位置，会移动到末尾。这时如果设置了max，当缓存内容超出这个范围时，就会删掉缓存中的第一项（因为最近访问的组件缓存都被移动到后面了，所以排在第一位的肯定就是最久未访问的了）。
### （3）mounted阶段
在mounted阶段，主要对include/exclude的值进行了监听，监听到值有变化时，说明需要被缓存的组件有改动，这时就会去遍历已缓存的组件，判断哪些已经不需要被缓存，然后将它们移除出缓存数据。
### （4）destroyed阶段
在destroyed阶段，说明keep-alive组件要销毁了，那它组件实例上的一些方法和属性也都会被销毁，因此在这个阶段就会清除所有已缓存的组件实例。

____________________________________________________
react


# react 生命周期（3个）

## 1. 挂载阶段(Mounting): 
这是当组件实例被创建并插入到DOM中的阶段

 1. constructor()
  - 这是组件构造函数，最初被创建的时候会被调用
  - 在这里通常会对state进行[初始化]和[事件处理函数的绑定]。

 2. static getDerivedStateFromProps()
  - 它是一个纯函数，不能在这个函数中执行副作用操作。
  - 当props发生变化或者在初始化挂载时，可以用来[更新state]

 3. render()
  - 用于告知React如何[渲染组件]。

 4. componentDidMount()
  - 在组件被加入到DOM后立即执行
  - 通常在这里进行[异步数据请求]。


## 2. 更新阶段(Updating)
这是当组件的props或者state发生变化，需要对UI进行更新的阶段

 1. static getDerivedStateFromProps()
  - 当props发生变化或者在初始化挂载时，可以用来[更新state]
  - 它是一个纯函数，不能在这个函数中执行副作用操作。

 2. shouldComponentUpdate()
  - 决定了组件[是否需要重新渲染]

 3. render()
  - 执行完成后会[生成新的虚拟DOM]

 4. getSnapshotBeforeUpdate()
  - 这个方法在DOM[更新的瞬间]被调用，
  - 可以在这个方法中捕获一些DOM信息，然后在componentDidUpdate中使用。

 5. componentDidUpdate()
  - 这个方法在组件[更新完成后]被调用，可以在这里进行额外的操作。进行异步请求


## 3. 卸载阶段(Unmounting)
当组件不再被需要，从DOM中移除的阶段，涉及的生命周期方法包括：

 1. componentWillUnmount()
  - 这个生命周期方法在组件[即将被销毁和卸载前]执行，
  一般会在这里进行清理操作，比如定时器的清理，取消网络请求等。



# react渲染过程（2个）


## Render阶段（或者称为Reconciliation阶段）：


这个阶段是纯粹的JS计算阶段，可被打断。当props或者state改变时，React会首先调用render函数，根据最新的props和state返回新的JSX结构。然后，React将这个新的JSX结构与上一次render的结果进行differencing（或者叫Reconciliation），比较出虚拟DOM树上发生了哪些变更。注意，这个阶段结束后，页面还没有进行真正的更新。


## Commit阶段


紧接着在React中，组件的渲染可以划分为两个阶段：Render阶段和Commit阶段。


## Render阶段
这是一个可能会多次重复执行的阶段，这是因为React可能会因为优先级和其它原因多次预渲染。
在这个阶段，React会计算需要对DOM进行哪些修改。
这个阶段的工作是可以被打断的，因此如果有更高优先级的任务来了，React可以放下这个阶段的工作，先去做其他的任务。
这就是所谓的时间切片（Time Slice）

在此阶段，执行的生命周期方法有
constructor, 
getDerivedStateFromProps, 
render, 
componentWillMount, 
componentWillReceiveProps，
和Redux的mapStateToProps。


## Commit阶段
在这个阶段，React会确保不会再有任何打断，它将会把在Render阶段计算出的改动应用到DOM上，然后调用组件的生命周期方法和副作用函数。
该阶段不能被打断，保证了用户界面的一致性。

在此阶段，执行的生命周期方法有
componentDidMount, 
componentDidUpdate, 
componentWillUnmount，
以及setState的回调函数。


————————————————————————————————————————————————————————————————
# applet生命周期

## （1）应用生命周期
1. onLaunch 初始化
2. onShow  小程序启动或切前台
3. onHide  小程序切后台

## （2）页面生命周期
1. onLoad   监听页面加载
2. onShow   监听页面展示 <———> onHide
3. onReady  监听初次渲染完成
4. onUnload 监听页面卸载
## （3）组件生命周期
需要在 lifetimes 字段内进行声明
1. created：组件实例创建完毕
2. attached：模板解析完成挂载到页面.
      这时候 this.data 已经被初始化，可以进行数据绑定操作
3. ready：组件在页面中位置确定后触发（较少用）
4. moved：组件实例被移动到节点树的另一个位置时触发
5. detached：组件被销毁

## （4）小程序冷启动，钩子函数执行顺序
应用：onLunch --> onShow
页面：                     -->onLoad -->onShow |           -->onReady
组件：created --> attached |                   --> ready --|
