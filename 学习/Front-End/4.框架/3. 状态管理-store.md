# vuex

Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。

Vuex 的状态存储是响应式的。
  当 Vue 组件从 store 中读取状态的时候，
   若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。

## vuex 状态改变的流程

1. 【vue components】 接收用户操作交互行为，
2. 执行【dispatch】触发的action进行回应
3. 若状态需要改变， 调用【commit】提交mutation修改state,
4. 通过getters获取state的新值，
5. 重新渲染vue Components

## vuex 属性

1. state         [存储状态---数据]
2. getters       [state的计算属性]， 用于读取state,并进行计算处理
3. mutations     [修改state的方法]， 直接修改state, 必须同步执行
4. actions       [异步修改state的方法]，通过提交mutations来修改数据 （ 并非直接更新数据 ）
   【commit】   执行mutations的方法，直接修改状态
   【dispatch】 执行action的方法，   间接修改状态

---

# pinia

Pinia 是 拥有组合式 API 的 Vue 状态管理库

`pinia`在 `Vuex`的基础上去掉了 `mutation`，将 `action`作为 `同步和异步`共用的操作方法，并且去掉了 `module`属性，
因为每定义一个store就相当于一个模块。因此它一共有 `三个属性`：`state`、`getter`、`action`。

## pinia优点

1. 更加轻量级，压缩后提交只有1.6kb。
2. 完整的 TS 的支持，Pinia 源码完全由 TS 编码完成。
3. 移除 mutations，只剩下 state 、 actions 、 getters 。
4. 没有 Vuex 那样的模块镶嵌结构，只有 store 概念，并支持 多个 互相独立隔离 的 store
5. 无需手动添加每个 store，它的模块默认情况下创建就自动注册。
6. 支持服务端渲染（SSR）。
7. 支持 Vue DevTools。

---

## vuex刷新数据是否丢失？

  vuex会重新获取数据， 页面也会丢失数据

- 解决：
  1. 把数据保存在浏览器缓存里（cookie, localstorage, sessionstorage）
  2. 页面刷新时， 再次请求数据， 达到可以动态更新数据的方法

## vuex和pinia区别

* 使用方式不同，`pinia`和 `vuex`是两个不同的库，因此在使用方式上有些 `细微差别`；
* `pinia`支持compositionApi的格式，更加贴合Vue3；
* `pinia`的语法和使用方式更加简洁，调用 `action`的方法时无需使用 `dispatch`；

# Redux

Redux 是一个管理全局应用状态的库，使用 "单向数据流"

## 3.1 核心概念

- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
- State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这种时点的数据集合，就叫做State。

---

- Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应该要发生变化了。
- Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
- dispatch：是View发出Action的唯一方法。

---

Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参数，返回一个新的State。

## 3.2 Redux 改变数据的流程

- 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
- 然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State
- State一旦有变化，Store就会调用监听函数，来更新View。

## 3.3 组件中 使用 状态和操作

  useSelector   [使用store的数据]，不能修改
  useDispatch   [修改store的数据], 同步方法

## 3.4 redux-thunk异步请求

redux-thunk 是一个 Redux 中间件，它允许你推迟 action 的 dispatch（分发），以便你可以在 dispatch action 前进行异步操作。redux-thunk 使得你可以在 action creator 中执行有状态的逻辑，如异步数据获取。

### 3.4.1 redux-thunk 用法

- 1. 配置 Store：
     在创建 Redux store 时，将 redux-thunk 作为中间件添加进去：

```js
import { createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';
import rootReducer from './reducers';

const store = createStore(rootReducer, applyMiddleware(thunk));
```

- 2. 编写异步 action creator：
     使用 redux-thunk 编写一个返回函数而不是 action 对象的 action creator：

```js
const fetchUser = userId => {
  return dispatch => {
    dispatch({ type: 'FETCH_USER_REQUEST' });

    return fetch(`/api/users/${userId}`)
      .then(response => response.json())
      .then(user => {
        dispatch({ type: 'FETCH_USER_SUCCESS', payload: user });
      })
      .catch(error => {
        dispatch({ type: 'FETCH_USER_FAILURE', payload: error });
      });
  };
};
```

- 3. 触发异步 action：
     在组件中触发异步 action：

```js
import React, { useEffect } from 'react';
import { useDispatch } from 'react-redux';
import { fetchUser } from './actions';

const UserComponent = ({ userId }) => {
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(fetchUser(userId));
  }, [userId, dispatch]);

  return (<div>Loading...</div>);
};
```

### 3.4.2 redux-thunk 作用

redux-thunk 的主要作用是处理异步 action，它允许开发者：

- 在 action creator 中执行异步逻辑。
- 在 dispatch action 前执行额外的逻辑处理。
- 保持 action 的顺序性，例如，在异步操作开始前 dispatch 一个请求 action，在异步操作完成后 dispatch 一个成功或失败的 action。

# Zustand

## 1. 创建仓库

  返回 状态 与 方法

## 2. 异步支持

  直接在函数中编写异步逻辑，
  最后把接口的数据放到set函数中返回即可

## 3. 切片模式

  类似于[模块化]
  场景：当我们单个store比较大的时候，
  可以采用一种 `切片模式`进行模块拆分再组合

```javascript
import { create } from 'zustand'

// 创建channel相关切片
const createChannelStore = (set) => {
  return {
    count: 0, // 状态
    inc: () => { // 修改状态的方法
      set(state => ({ count: state.count + 1 }))
    }，
    channelList: [], 
    fetchChannelList: async () => { // 异步逻辑
      const res = await fetch(URL)
      const jsonData = await res.json()
      set({channelList: jsonData.data.channels})
    }
  }
}
// 创建counter相关切片
const createCounterStore = (set) => {
  return {
    count: 0,
    setCount: () => {
      set(state => ({ count: state.count + 1 }))
    }
  }
}
// 组合切片
const useStore = create((...a) => ({
  ...createCounterStore(...a),
  ...createChannelStore(...a)
}))

export default useStore
```

app.js - 绑定组件

```jsx
import { useEffect } from 'react'
import useChannelStore from './store/channelStore'

function App() {
  const {count, inc, channelList, fetchChannelList } = useStore()
 
  useEffect(() => { // 进行异步操作
    fetchChannelList()
  }, [fetchChannelList])

  return (
    <ul>
      {channelList.map((item) => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  )
}
```
