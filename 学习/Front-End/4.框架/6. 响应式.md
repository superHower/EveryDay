## 1. 虚拟dom

1. 实现原理
   1）用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；
   （2）diff 算法 — 状态变更时，比较新树和旧树的差异
   （3）pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。
2. 优点：

- （1）保证性能下限：
  框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，
  它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的， 但是比起粗暴的 DOM 操作性能要好很多；
- （2）无需手动操作 DOM：
  我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，
  框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；
- （3）跨平台：
  虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，
  相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。

4. 缺点:
   - 无法进行极致优化：
   - 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。

## 2. Vue2和Vue3的响应式原理

### 什么是响应式

`响应式`就是在我们修改数据之后，无需 `手动`触发视图更新，视图会自动更新。

### Vue2响应式实现

`Vue2`中，响应式系统是通过 `依次遍历`data返回的对象，
将里面每一个属性通过 `Object.defineProperty`进行定义，

- 在 `属性描述符`中添加 `get/set`，实现 `getter/setter方法`，
- 在 `访问属性`时，在getter函数中 `收集依赖`（记录哪些方法或变量在使用这个属性），
- 在 `修改属性`时，在setter函数中 `派发依赖`（将收集到的依赖依次更新），从而达到 `响应式`。

### Vue3响应式实现

`Vue3`中，响应式系统是通过 `ES6中的Proxy`实现对一个对象的 `代理`，
然后设置 `handler.get/handler.set`，

- 在对 `代理对象`进行操作时，可以触发 `get/set`，
- 在get中实现 `收集依赖`，
- 在set中实现 `派发依赖`，从而达到 `响应式`的效果。

## 3. Vue3为什么要改为Proxy实现响应式？

### 3.1 Object.defineProperty()的缺点

1. 只能监听 `对象的属性`

- 当我们想对 `某个对象`进行监听时，必须将这个对象 `遍历`，
- 然后对其中的每一个属性进行监听。
- 如果说对象中的某个属性又是一个对象，那就需要 `递归遍历`，
- 将每一层都进行监听，这样的性能肯定是比较低的。

2. 只能监听 `已有属性`

- 在Vue2中，`created()阶段`Vue内部已经帮我们把data中的属性遍历完毕并且对每个属性进行监听了，
- 如果在之后的阶段我们给某个对象 `使用obj.xx的方式`给对象添加了一个新属性，
- 这个属性就 `不再是响应式了`（这也是为什么我们在添加新属性时，需要使用 `this.$set`的方式）

3. 不能监听 `数组长度的改变`

- 在使用一些 `影响原数组`的数组方法时，它监听不到，
- 比如我们使用 `pop、shift、push`等，（这也是为什么 `Vue2要重写部分数组原型方法`）

> `Object.defineProperty`不能监听数组长度变化，但是它是可以监听 `数组内容`变化的，
> 前提是我们需要像对象一样，把数组进行遍历，然后对 `每一个索引值`进行监听。

### 3.2 Proxy改变了什么

1. 首先针对Object.defineProperty的第一个缺点，`Proxy`的作用是 `返回一个代理对象`，因此它不需要再 `遍历/深度遍历`一个对象，而是只需要将 `原对象作为参数传入`，就可以返回该对象的 `代理对象`，并且它的第二个参数 `handler`提供了 `13种`方法，能够监听代理对象的各种操作。
2. 针对Object.defineProperty的第二个缺点，当我们对 `代理对象`使用 `obj.xx`的方式添加一个新属性时，它依旧能够对新添加的数据进行监听。
3. 针对Object.defineProperty的第三个缺点，`Proxy`不仅可以监听数组索引值的变化，还能够监听 `原型方法（pop、push）`等。

## 4 Diff算法

### 4.1 什么是diff算法
diff算法就是比较新旧虚拟节点（VNode），对旧节点进行更新、删除、新增操作，然后更新到真实的DOM上。
- diff算法只会同层对比，不会跨层级，比如一个旧节点不会与新节点的子节点去进行对比；
- diff算法一般都是从两端开始对比，逐渐向中间收拢；

### 4.2 Vue2和Vue3的diff算法区别

- Vue 2.x使用的是[双向指针遍历]的算法，
  也就是通过逐层比对新旧虚拟DOM树节点的方式来计算出更新需要做的最小操作集合。
  但这种算法的缺点是，由于遍历是从左到右、从上到下进行的，
  当发生节点删除或移动时，会导致其它节点位置的计算出现错误，
  因此会造成大量无效的重新渲染。
- Vue 3.x使用了经过优化的[单向遍历算法]，
  只扫描新虚拟DOM树上的节点，判断是否需要更新，跳过不需要更新的节点，进一步减少了不必要的操作。
  此外，在虚拟DOM创建后，Vue 3会缓存虚拟DOM节点的描述信息，以便于复用，这也会带来性能上的优势。
  同时，Vue 3还引入了静态提升技术，在编译时将一些静态的节点及其子节点预先处理成HTML字符串，大大提升了渲染性能。

### 4.3 Vue3在diff阶段都优化了哪些？

- 静态提升：在模板编译时，会将没有用到动态变量的节点或属性(class、style这些元素属性)进行静态提升，在进行render时，直接复用旧节点。而在Vue2中，无论元素是否使用了动态变量，每次更新都会重新创建，这也是为什么Vue3最好使用template而不是render函数，因为模板编译时会帮我们做优化；
- 预字符串化：当编译器遇到大量的静态节点时，会将这一整部分变成字符串，减少VNode的创建，渲染为静态节点，而在Vue2中，则会将这些节点一个个变成虚拟节点；
- 缓存事件处理函数：在Vue3中，会将dom元素绑定的事件进行缓存，在进行patch的时候会使用缓存中的事件处理函数；

# 5. $nextTick的作用是什么，原理是什么？

    $nextTick是 Vue.js提供的一个异步更新DOM的方法。因为Vue的更新是异步的，如果你想在改变某个属性之后立即去操作DOM，可能结果并不是你想要的，而nextTick允许你在当前 DOM 更新循环结束之后执行一个回调函数，这样可以确保在回调函数中操作的DOM是最新的。
    Vue2和Vue3中使用nextTick的方式和实现的原理都不一样。

# 6. Vue3中ref和reactive的区别是什么？

（1）reactive

```js
export function reactive(target: object) {
  // if trying to observe a readonly proxy, return the readonly version.
  if (isReadonly(target)) {
    return target
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  )
}
```

从源码可以看出，reactive需要传入一个对象，如果是一个只读的对象，那就返回原对象，否则就调用createReactiveObject()函数，返回一个经过Proxy代理的对象。
（2）ref

```js
function createRef(rawValue: unknown, shallow: boolean) {
  if (isRef(rawValue)) {
    return rawValue
  }
  return new RefImpl(rawValue, shallow)
}

class RefImpl `<T>` {
  private _value: T
  private _rawValue: T

  public dep?: Dep = undefined
  public readonly __v_isRef = true

  constructor(
    value: T,
    public readonly __v_isShallow: boolean
  ) {
    this._rawValue = __v_isShallow ? value : toRaw(value)
    this._value = __v_isShallow ? value : toReactive(value)
  }

  get value() {
    trackRefValue(this)
    return this._value
  }

  set value(newVal) {
    const useDirectValue =
      this.__v_isShallow || isShallow(newVal) || isReadonly(newVal)
    newVal = useDirectValue ? newVal : toRaw(newVal)
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal
      this._value = useDirectValue ? newVal : toReactive(newVal)
      triggerRefValue(this, newVal)
    }
  }
}

从源码可以看出，创建一个ref变量，如果传入的变量已经是一个ref变量了，就直接返回这个变量，如果不是就会返回一个new RefImpl()，new这个类又做了什么呢？其实就是把我们传入的变量进行toReactive然后赋值给this._value，当我们访问value的时候，通过get函数，给我们返回了this._value。说白了就是给我们的变量包裹了一层对象，然后转变成了reactive对象。
（3）区别
既然都是用reactive实现的，为什么不都用reactive呢？这就要说到它们的区别了。

Vue3的响应式原理是基于Proxy的，而Proxy只能代理对象，如果我们要实现一个基本数据类型的响应式怎么办呢？只能通过将它变成对象的方式；
reactive只能传入一个对象，而ref可以传入任何类型；
ref声明的变量，我们在访问时，除了模板之外，必须使用xxx.value，而reactive不用；
reactive声明的变量可能会造成响应式丢失，这也是为什么官方更推荐使用ref的原因；

（4）reactive响应式丢失
html复制代码 `<script setup>`
import { reactive } from 'vue'
let obj = reactive({
  a: 1,
  b: 2
})

obj = {
  a: 2,
  b: 1
}
`</script>`

乍一看这种方式挺正常的，但是这种方式会引起响应式丢失，第一次使用reactive创建对象obj时，obj是一个正常的被Proxy代理的对象，它是响应式的。但是当我们给obj重新赋值时，相当于改变了obj的内存地址，此时obj变成了一个非响应式的普通对象，于是造成了响应式丢失。
为什么ref不会产生这种问题呢？
html复制代码 `<script setup>`
import { ref } from 'vue'
let obj = ref({
  a: 1,
  b: 2
})

obj.value = {
  a: 2,
  b: 1
}
`</script>`

当我们使用ref创建响应式变量时，其实是类似这样的：
html复制代码 `<script setup>`
import { reactive } from 'vue'
let obj = reactive({
  value: {
    a: 1,
    b: 2
  }
})

obj.value = {
  a: 2,
  b: 1
}
`</script>`

这时我们改变的其实是obj对象的value属性，并没有更改整个对象，于是不会造成响应式丢失。
如果想使用reactive，一定要确保修改对象时修改的是对象的某个属性，如果想对reactive对象重新赋值，就必须要再次包裹一层reactive，但是不建议这么做。
使用reactive时，进行解构操作，也会丢失响应式，这是因为在解构赋值中，如果是原始类型就是按照值传递，如果是引用数据类型就会按照引用类型地址传递，因此解构出来的值并不是一个响应式的。
```
