# 1. 变量与作用域

## 1.1 变量声明

在js中，变量的声明方式在ES6之前只有var一种，而在ES6之后有var、let、const三种方式。

- var：声明一个变量，在该变量被声明之后，可以在下文代码中对该变量进行重新赋值，并且每次赋值都会覆盖上一次的值，它不受限于块级作用域，但受限于局部作用域；
- let：和var一样，用于声明一个变量，但是let声明的变量只在当前块级作用域中生效，只有在当前块级作用域内进行重新赋值，才会覆盖上一次的值；
- const：用于声明一个常量，和let一样，只在块级作用域中生效，并且不可以重新赋值。

```js
if (true) {
    var a = 1
    a = 2
    console.log(a) // 2
}
console.log(a) // 2

if (true) {
    let b = 1
    b = 2
    console.log(b) // 2
}
console.log(b) // Uncaught ReferenceError: b is not defined

if (true) {
    const c = 1
    c = 2
}
// Uncaught TypeError: Assignment to constant variable.

if (true) {
    const c = 1
    console.log(c) // 1
}
console.log(c) // Uncaught ReferenceError: c is not defined
```

- 使用var声明的变量，不仅可以在if代码块中可以访问并且可以重新赋值，而且可以在if代码块之外进行访问；
- 使用let声明的变量，仅可以在if代码块中可以访问并且可以重新赋值，不可以在if代码块之外进行访问；
- 使用const声明的常量，无法进行重新赋值，并且无法在if代码块之外进行访问；
- 之所以var可以在if代码块外进行被访问，是因为var不受限于块级作用域，而let、const受限于块级作用域；

## 1.2 变量提升

变量提升就是js引擎在解析代码时，会预先将声明变量的操作进行提前，这种行为就称为变量提升。

```js
console.log(a) // undefined

var a = 1
```

众所周知，js代码是由上而下执行的，在打印变量a时，还未执行var a = 1这一步，为什么没有报错，而是打印出了undefined呢？
这是因为js引擎在解析代码时，会预先将声明变量的操作进行提前，并且默认赋值为undefined，因此上面的代码在js引擎帮助我们解析之后，其实变成了下面的代码：

```js
var a = undefined
console.log(a) // undefined

a = 1
```

如果是函数呢？

```js
console.log(a) // ƒ a() { ... }
var a = 1

function a() {
    console.log('i am function')
}
```

我们发现，当声明一个变量a，并且创建一个函数a时，同样会变量提升，并且默认值不再是undefined，而是函数内容，这说明在进行变量提升时，函数的优先级要高于普通变量；

之所以函数进行变量提升时，默认值不是undefined，是因为V8引擎在解析代码时，如果发现是函数，会预先在内存中开辟一块新的地址，用于存放函数内容，里面存放了函数的作用域（[[scope]]），该作用域指向其父级作用域，并且还存放了函数的执行体。因此在变量提升时，我们访问该函数，访问的其实是函数的内存地址，里面有函数体，因此访问的结果不是undefined。

## 1.3 使用let、const

```js
console.log(a) // Uncaught ReferenceError: Cannot access 'a' before initialization
console.log(b) // Uncaught ReferenceError: Cannot access 'b' before initialization

const a = 1
let b = 2
```

可以看到，在使用let和const声明的变量声明之前访问变量时，会发生报错信息初始化前无法访问“a/b”，这也是let和const解决的一个问题，解决了变量提升的问题，但是let和const并不是不会进行变量提升了，而是因为暂时性死区的原因。

## 1.4 暂时性死区

暂时性死区指的是通过let和const声明的变量，在声明之前，不能对其进行访问。

但是这并不能说明let和const不会进行变量提升，如果不会进行变量提升的话，之间访问应该是会报Uncaught ReferenceError: xxx is not defined的，但是并没有，而是提示我们Cannot access 'x' before initialization，只是对它们的访问进行了限制。

## 1.5 var、let、const的区别

- 在当前作用域中，使用三者声明变量，都只能在当前作用域进行访问；
- let和const会受到块级作用域限制，var不会；
- 三者都存在变量提升，但是let和const因为暂时性死区的关系，无法在声明前进行访问；
- var和let声明的变量，在当前作用域链中可以被修改，const无法被修改；
- 在全局作用域中，使用var声明变量时，会将变量存放进window对象，let和const不会；
- let和const在ES6中出现，因此只能在支持ES6的环境中使用，而var没有这个限制。

## 2. 作用域和作用域链

### 2.1 GO、AO、VO、VE

js的运行是单线程的，因此，js代码在执行的过程，更像是一个进栈、出栈的过程，js引擎（拿V8来说）在执行代码时，会创建一个执行上下文栈（Execution Context Stack）。

在执行全局代码时，会创建一个全局执行上下文（Global Context），然后将其放入执行上下文栈进行执行，期间会创建一个变量对象VO（Variable Object），开始执行代码时，V8内部会帮助我们创建一个全局对象GO（Global Object），GO中会存放一些全局变量以及全局方法，此时VO指向GO；

在执行全局代码中的函数时，会创建一个函数执行上下文（Functional Execution Context），然后将其放入执行上下文栈进行执行，期间会创建一个VO，开始执行代码时，会创建一个局部活跃对象AO（Activation Object），AO中会存放一些局部变量、局部方法以及函数的参数，此时VO指向AO；

由此我们知道：

每一个执行上下文（可能是全局，也可能是函数）创建时，都会创建一个变量对象VO，根据执行上下文的不同，VO的指向也不同；
GO保存的是全局变量以及全局方法，只有在整个文件执行完毕时，才会销毁；
AO保存的是函数的局部变量以及局部方法，在函数运行完毕时，会被销毁；

VE是什么？VE其实就是最新的ECMA标准中把VO的概念改为了VE（Variable Environment（变量环境）），环境中定义的一些变量或函数将会作为一条环境记录（environment record）绑定在变量环境中，之所以更改是因为之前的VO、GO、AO，我们通常把它们定义为对象，但是这种方法太笼统了，在ES6之后，有许多数据结构的出现，比如Map等，因此把VO的定义改为不只局限于对象，更加的严谨，更加的灵活。

### 2.2 作用域

作用域指的就是当前代码的执行上下文，在全局执行上下文中就是GO，在函数执行上下文中就是AO。
在js中，常见的作用域有以下几种：

全局作用域：脚本中所有代码的默认作用域，也就是说 `<script>`标签内所有代码默认的作用域；
模块作用域：在模块化开发中，每一个模块都有自己的作用域；
函数作用域：每创建一个函数，函数体内就是一块独立的函数作用域；
块级作用域：由let、const衍生出来的一种作用域，每个花括号（{}）创建出来的代码块，就是块级作用域；

### 2.3 作用域链

当我们在当前作用域中（假设当前在某个函数的AO中）访问、修改某个变量时，如果发现当前作用域没有这个变量，就会去上层作用域（上一个AO或者GO）进行查找，直至找到全局作用域（GO），如果还没有，就会报错。这种类似链条形式逐级向上查找的模式，我们称之为作用域链。

### 2.4 延长作用域链的方法

闭包：其原理是函数（a）内返回一个函数（b），然后在全局作用域中调用b，按照正常逻辑，函数b的作用域链应该为b的AO -> 全局变量(GO)，但是由于函数b是在函数a内创建的，它在创建时，就记录了父级作用域（函数a的AO），因此此时函数b的作用域链应该为b的AO -> a的AO -> 全局变量GO。
with语句：已经属于废弃功能，格式为with(obj) { ... }，它会将{}内的代码的上层作用域指向obj，相当于延长了内部代码的作用域链；
try...catch的catch语句：之所以catch(e)能接收到错误信息，是因为在try语句报错时，会将报错信息放到catch语句的作用域链最前端，因此在catch语句之中，才能访问到错误信息；

# 3. 数据类型和数据结构

## 3.1 基本数据类型 7个

number（数字类型）、string（字符串类型）、boolean（布尔型）、
undefined（未定义）、null（空）、
bigint（大数）、Symbol（独一无二的值）。

## 3.2 引用数据类型

引用数据类型只有object（对象）。

## 3.3 数据结构

js的数组、函数，不属于数据类型，

在js中，array（数组）、function（函数）、Map/WeakMap（字典）、Set/WeakSet（集合），
它们都是在object类型之上进行拓展，所衍生出来的一些数据结构。

### 3.3.1 Map和Set有何不同，WeakMap和WeakSet又是什么？

（1）相同点

Map和Set都是一种数据结构，可以作为存放内容的容器；

Map和Set相较于普通的数组array来说，查找效率更快；

Map和Set都通过delete方法来删除数据；

Map和Set都通过has方法来获取元素是否在集合中；

（2）不同点

Map的值类似于一个二维数组，而Set的值是一个伪数组（其实是一个对象，但是可以通过索引去访问）；

Map更像是一个字典，存储的数据由key: value的格式组成，而Set更像是一个集合，里面存储了一个个的值；

Map的键名不会重复，Set则是值不会重复；

Map通过get方法访问数据，Set则只能通过遍历或者转成数组，再去访问；

Map通过set方法去添加数据，Set则是通过add方法去添加数据；

（3）WeakMap和WeakSet

WeakMap、WeakSet它们的作用其实和Map还有Set大概相同，它们的出现是为了处理使用Map和Set时出现的内存泄漏问题，它们的区别有以下几点：

WeakSet和WeakMap中只能存放对象，而不像Map和Set一样可以存放任意类型；

WeakSet中存放的对象，以及WeakMap中作为键名的对象，都是弱引用，当这个对象只作为WeakSet的值，或者只作为WeakMap的键名时，会被垃圾回收器回收。

### 3.3.2 BigInt和Number的区别

在js中number类型只能表示-2^53 + 1 到 2^53 - 1 范围内的整数，超过这个返回就会精度丢失，而bigint的出现，就是为了能够让js正确的表示不在这个区间范围内的整数；

可以在一个整数字面量后面加n的方式定义一个BigInt，也可以调用BigInt()函数，并且传递一个整数值或字符串。但是不能使用new运算符。

（1）和Number的相同点

在if条件语句中，BigInt和Number类似；

在Boolean转换时，BigInt和Number类似；

BigInt类型的数据可以和Number类型的数据进行比较，但是结果是宽松相等（== 才成立， === 不行）的；

BigInt和Number类似，可以使用+、-、*、/、%等运算；

BigInt可以和Number类型的数据放在同一数组进行排序；

（2）和Number的不同点

类型不同：进行类型判断时，二者类型不同；

不能使用Math对象：不能使用Math对象的一些方法，比如Math.floor、Math.ceil等；

不能和Number运算：不能和Number类型的数据进行运算，必须要转换成同一类型才可以，但是转换的过程可能会精度丢失；

BigInt的数据不能使用JSON.stringify()；

（3）什么时候使用BigInt

当我们要表示一个大数时，这个大数的值已经不能用Number类型来表示了，并且我们不打算将它转换成Number类型的情况下，可以考虑使用BigInt。

（4）BigInt会造成的问题

BigInt也会造成精度丢失的问题，如果你使用BigInt函数创建一个BigInt，并且你的传参是整数，在传参的过程中，会造成精度丢失的问题；

```js
const myBig = BigInt(99999999999999999)

const yourBig = BigInt('99999999999999999')

console.log(myBig) // 100000000000000000n

console.log(yourBig) // 99999999999999999n
```

BigInt在进行/运算时，结果中会向下取整，因为BigInt只能表示整数；

```js
const big = 5n

console.log(big / 2n) // 2n，而不是2.5n
```

### 3.3.3 NaN是什么

NaN 是一个表示非数字的值，它及其行为不是JavaScript发明的。它在浮点运算中的语义（包括 NaN !== NaN）是由 IEEE 754 指定的。

可以通过isNaN()方法，去判断一个值是否为NaN；

NaN通过（==、===）与其他任何值（包括NaN）对比，结果都为false；

当NaN是任何关系比较（>, <, >=, <=）的操作数之一时，结果总是 false；

如果NaN涉及数学运算（但不涉及位运算），结果通常也是NaN（除了NaN ** 0 = 1除外）；

### 3.3.4 undefined和null的区别

（1）undefined

undefined通常表示未定义的值，它在js中表示一个变量最原始的状态，当一个变量没有被赋值时，它的值就是undefined。

typeof undefined的值是undefined；

Number(undefined)的值为NaN；

创建新变量，并且未对变量赋值时，值默认为undefined；

调用函数时，未给形参传值，函数内部接收到的参数的值为undefined；

函数没有return，默认会return undefined，所以函数的默认返回值为undefined；

访问对象中没有的属性，会返回undefined；

使用void运算符，返回值为undefined；

（2）null

null通常表示空指针，它意为没有指向任何对象，在预期中，它的值应该是一个对象，但是又没有关联的对象。

typeof null的值为object；

Number(null)的值为0；

null通常由开发者手动赋值，而不会作为默认值存在；

（3）总结

undefined在许多场景下被作为默认值，而null通常是由开发者手动赋值；

通过运算符对undefined和null进行操作的结果不同；

二者类型不同，含义不同；

# 4. 如何判断数据的类型

## 4.1 基本数据类型

基本数据类型的判断，我们通常可以使用typeof方法进行判断。

```js
 const n = 1

 const s = '1'

 const b = true

 const u = undefined

 const no = null

 const big = 1n

 const sym = Symbol(1)

 console.log(typeof n) //number

 console.log(typeof s) // string

 console.log(typeof b) // boolean

 console.log(typeof u) // undefined

 console.log(typeof no) // object

 console.log(typeof big) // bigint

 console.log(typeof sym) // symbol
```

我们发现，基本数据类型，用typeof都...不对劲啊，怎么混进去了奇怪的东西，typeof null的值竟然是object！

## 4.2 为什么typeof null是object

这是因为JavaScript历史原因，在javaScript最初的实现中，js的值是由表示类型的标签和实际数值表示的，
而恰好object的类型标签是0，null又代表空指针，在大多数平台下解析到的类型标签也是0，所以typeof的值也就变成了object；

这也是为什么我们在判断引用数据类型的时候不能全靠typeof的一个原因，因为在某些特殊场景下，它会容易让我们的结果产生混淆。

## 4.3 判断引用数据类型

使用typeof来判断几种常见的引用数据类型。

```js
const f = function () {}

const o = {}

const a = []

const m = new Map()

const s = new Set()

const d = new Date()

console.log(typeof f) // function

console.log(typeof o) // object

console.log(typeof a) // object

console.log(typeof m) // object

console.log(typeof s) // object

console.log(typeof d) // object
```

发现除了function可以正常识别之外，其他全都是object，所以说面对引用数据类型，我们已经不能用typeof来进行判断了。

## 4.4 使用instanceof

instanceof运算符一般用于检测构造函数的prototype属性是否在对象的原型链上出现。

```js
const f = function () {}

const o = {}

const a = []

const m = new Map()

const s = new Set()

const d = new Date()

console.log(f instanceof Function) // true

console.log(o instanceof Object) // true

console.log(a instanceof Array) // true

console.log(m instanceof Map) // true

console.log(s instanceof Set) // true

console.log(d instanceof Date) // true

console.log(f instanceof Array) // false

console.log(a instanceof Map) // false

console.log(f instanceof Object) // true
```

由上面代码可以看出，比如我们函数的构造函数的prototype属性是Function，那它的原型链上就会有Function，我们就可以通过instanceof Function来判断该属性是否为函数，它原型链上没有Array，就会返回false，这个方法唯一的缺点就是所有的引用类型用instanceof Object判断时，结果都为true。

## 4.5 使用toString方法

js中所有的类型都源于对象，它们在原型链的顶端都是Object，而Object的原型上有toString方法，
我们可以通过调用Object.prototype.toString来判断它们的类型。

```js
const n = 1

const s = '1'

const big = 1n

const f = function () {}

const m = new Map()

const o = {}

console.log(Object.prototype.toString.call(n)) // [object Number]

console.log(Object.prototype.toString.call(s)) // [object String]

console.log(Object.prototype.toString.call(big)) // [object BigInt]

console.log(Object.prototype.toString.call(f)) // [object Function]

console.log(Object.prototype.toString.call(m)) // [object Map]

console.log(Object.prototype.toString.call(o)) // [object Object]
```

这里需要注意几个点：

得到的结果是[object xxxxxx]的格式，需要我们对结果进行匹配才能得知是什么类型；

之所以调用Object.prototype.toString而不是变量自身的toString方法，是因为不同类型变量构造函数中重写了toString方法，访问toString方法时，会优先使用自身的；

# 5. 类型之间的转换

## 5.1 js中所有的转换情况

在js中，一般只会发生以下几种转换：转为boolean（布尔值）、转为string（字符串）、转为number（数字类型）。

|类型|目标类型|转换结果|

|--|--|--|

| number    | boolean  | 除了+0、-0、NaN都为true                                                                    |

| number    | string   | 只是类型改变，具体内容不变                                                                 |

| number    | number   | 如果字符串内容为数字，就会转换成数字，否则转换成NaN                                        |

| boolean   | boolean  | 除了''（空字符串）都为true                                                                 |

| boolean   | string   | true = 'true'、false = 'false'                                                             |

| boolean   | number   | true = 1、false = 0                                                                        |

| string    | boolean  | 除了''（空字符串）都为true                                                                 |

| string    | string   | 只是类型改变，具体内容不变                                                                 |

| string    | number   | 如果字符串内容为数字，就会转换成数字，否则转换成NaN                                        |

| Symbol    | boolean  | 都为true                                                                                   |

| Symbol    | string   | 只是类型改变，具体内容不变                                                                 |

| Symbol    | number   | 报错                                                                                       |

| undefined | boolean  | 都为false                                                                                  |

| undefined | string   | 只是类型改变，具体内容不变                                                                 |

| undefined | number   | 为 NaN                                                                                     |

| null      | boolean  | 都为false                                                                                  |

| null      | string   | 只是类型改变，具体内容不变                                                                 |

| null      | number   | 为 0                                                                                       |

| 引用类型  | boolean  | 都为true                                                                                   |

| 引用类型  | string   | 视情况而定                                                                                 |

| 引用类型  | number   | 空数组为0，数组只有一项，且该项的值为number或者字符串类型的数字时，为该数字，其余情况为NaN |

| BigInt    | boolean  | 和number一样                                                                               |

| BigInt    | string   | 会把后面的n去掉                                                                            |

| BigInt    | number   | 会把后面的n去掉，如果是大数，会造成精度丢失                                                |

## 5.2 显式类型转换

显式类型转换指的就是我们通过代码将数据转换成我们预想之中的类型，也就是说，比如我们想把数字转换成字符串，我们通过toString方法去实现我们的目的，这种方式称为显式。

```js
let a = 1

a = a.toString()

console.log(typeof a) // string
```

## 5.3 隐式类型转换

隐式类型转换指的是我们在进行某种操作的过程中，代码内部编译时发生了类型转换，可能会发生我们预期之外的结果。

数字类型和字符串类型进行相加时，会先将数字转化为字符串然后相加；

数字类型和字符串类型进行-、*、/运算时，会先将字符串转化为数字然后进行运算；

在条件判断语句中使用非boolean类型时，会先转化为boolean类型然后判断；

在使用==进行比较时，如果两边是string和boolean会转换为数字类型再进行对比，但是undefined和null不会进行转换；

在使用==进行比较时，如果一边是object，一边是string、boolean、symbol，那么就会将object转换成原始类型再进行比较。

```js
const a = 1

const b = '2'

if (a) {

// if(1) -> 1会隐式转换为boolean类型的true

console.log('true')

} else {

console.log('false')

}

console.log(a + b) // '12'

console.log(a - b) // -1
```

## 5.4 对象转换成字符串

js中，引用数据类型在转换成字符串时，会比较特殊，一共有下面四个步骤：

如果对象有Symbol.toPrimitive()方法，优先调用该方法；

如果没有就会看是否有valueOf()方法，然后次调用该方法；

如果还没有，就会调用toString()方法；

如果还没有，就会报错；

我们平时如果想要将引用类型转变为字符串，通常会调用它的toString方法，为什么不同的引用类型的toString方法表现形式不一样呢？

这是因为某些类型在它们的原型链中重写了toSting方法。

```js
const obj1 = {}

const obj2 = {

    [Symbol.toPrimitive]: () => {

    return '123'

    },

}

const obj3 = {

    [Symbol.toPrimitive]: null,

    valueOf: () => {

    return '123'

    },

}

const obj4 = {

    [Symbol.toPrimitive]: null,

    valueOf: null,

    toString: () => {

    return '123'

    },

}

const obj5 = {

    [Symbol.toPrimitive]: null,

    valueOf: null,

    toString: null,

}

console.log(obj1 == '123') // false

console.log(obj2 == '123') // true

console.log(obj3 == '123') // true

console.log(obj4 == '123') // true

console.log(obj5 == '123') // Uncaught TypeError: Cannot convert object to primitive value
```

从上面代码我们发现，默认情况下，对象是不可能=='123'的，但是不管我们给对象设置了Symbol.toPrimitive、valueOf、toString，它和123进行非严格对比时，都返回了true，而当我们把这三个属性都设为null时，浏览器进行了报错。

## 5.5 特殊的类型转换

```js
console.log([] == ![]) // true
```

式子右侧![]先转换成boolean，变成了!true也就是false；

式子变成了[] == false；

然后进行等式两边转换为number类型进行比较；

左侧[]变成了0，右侧false变成了0，于是最终比对的就是0 == 0；

```js
console.log(Number(null)) // 0

console.log(Number(undefined)) // NaN

console.log(null == undefined) // true
```

null的含义为空指针，它代表一个空值，因此转换成number的时候，会变成0；

undefined的含义为未定义的，它代表一个不存在的值，在转换成number的时候相当于对一个不存在的值进行转换，因此会返回NaN；

但是对于null == undefined来说，它们在进行非严格对比时不会进行类型转换，也就是说它们对比的结果并不是转换成number再去对比的，而它们在代码中的语义都代表了没有值，所以在非严格对比的情况下，返回的是true；

# 6. 0.1+0.2为什么不等于0.3

在JavaScript中，不只是0.1+0.2，还有其他很多运算场景下，都会发生精度丢失的问题，而产生这种现象的根本原因就是所有计算在计算机层面来说都是二进制计算。
我们先来看一下十进制的小数是怎么转化成二进制的。
它的转化过程是这样的：

先将小数的整数位取出，然后进行/2操作，得到商和余数；
再用商 / 2，再次得到商和余数，直至商为0，此时所有余数拼接起来，就是整数部分；
再将小数的小数位取出，然后进行* 2操作，得到积；
再将积的整数位取出，然后继续用积的小数位 * 2，再次得到一个积；
重复上一步操作，直至小数位为0，此时所有的整数位就是小数部分转化为二进制的值；

使用0.625举例

整数位为0，/2的商直接为0，余数为0；
小数位为0.625，进行*2操作，变为1.25，取出整数部分1；
此时小数位为0.25，进行*2操作，变为0.5，取出整数部分0；
此时小数位为0.5，进行*2操作，变为1.0，至此结束，取出整数部分1；

那么0.625转化为二进制就是0.101。
那么0.2转化为二进制呢？它的结果是一个0.0011001100110011...无限循环，而0.3呢？它的结果是一个0.0100110011001100...也是无限循环，那它们两个值相加，肯定就不是0.3了，而是一个无限长度的小数。

# 7. 令a == 1 && a == 2 && a == 3成立

重写对象的Symbol.toPrimitive或valueOf或toString方法。

```js
const a = {
    num: 1,
    [Symbol.toPrimitive]: function () {
      return this.num++
    }
    // valueOf: function () {
    //   return this.num++
    // },
    // toString: function () {
    //   return this.num++
    // }
}

console.log(a == 1 && a == 2 && a == 3) // true
```

# 8. ===和==的区别

===是严格相等运算符，它会检查运算符两边的两个操作数值是否相等，并且类型是否相等，不同类型的两个操作数，即使值一样，也会被认为是不相等的；

==是非严格相等（宽松相等）运算符，它只会检查运算符两边的两个操作数值是否相等，如果类型不同的话，在JavaScript中，会根据规则对两边的操作数进行类型转换；
