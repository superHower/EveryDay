# 1. 数组

## 1.1 数组原型常用方法

数组原型上的常用方法有以下几种：

- arr.push(val)：在数组尾部插入一个或多个元素，并返回数组长度；
- arr.pop()：删除数组最后一个元素，并返回删除的元素；
- arr.unshift(val)：在数组头部插入一个或多个元素，并返回数组长度；
- arr.shift()：删除数组第一个元素，并返回删除的元素；
- arr.concat()：将两个数组进行合并，并返回合并后的新数组，原数组不会收到改变；
- arr.join()：将一个数组或类数组对象所有元素拼接成一个字符串，并以指定的分隔符进行分割（默认为“,”），如果数组只有一个元素，则不会产生分隔符，返回这个字符串；
- arr.indexOf()：可以接收两个参数，该方法会找到第一个参数参数在数组中第一次出现的索引，并返回这个索引，第二个参数的作用为从数组第几项开始查找，如果没有找到，则返回-1；
- arr.includes()：可以接收两个参数，会判断第一个传入的参数是否为数组的子元素，第二个参数的作用为从数组第几项开始，返回值为boolean；
- arr.forEach()：将一个数组进行遍历，每次遍历可以执行给定的函数；
- arr.flat()：将一个多维数组拍平，传参为多维数组的层级（即要拍平几次），传入Infinity即为无限（直到拍平为止），并返回一个新的数组；
- arr.filter()：遍历一个数组，并且根据传入的回调函数，将所有符合规则的元素放在一个新数组中返回，不会改变原数组；
- arr.find()：遍历一个数组，并且根据传入的回调函数，返回符合条件的第一个元素；
- arr.findIndex()：类似arr.find()，但是返回的是元素在数组中对应的角标；
- arr.map()：遍历一个数组，每个元素会根据传入的回调函数重新拼装，并返回一个新数组，不会影响原数组；
- arr.some()：遍历一个数组，根据传入的回调函数，只要有一个元素条件不满足，就会返回false，否则返回true；
- arr.every()：类似some，但所有元素不满足条件时，才会返回false；
- arr.slice()：传入两个参数，分别为开始的索引和结束的索引，会根据参数区间截取原数组的一部分，并返回一个新的函数，如果值为负数，会进行+arr.length计算转换为正数；
- arr.splice()：传入三个参数，可以对原数组进行移除或替换操作，第一个参数为起始位置，第二个参数为要删除/修改的个数，第三个参数是可选的，如果传入则代表替换，没传则代表删除，该方法会返回一个数组，如果移除了元素，就返回被移除元素组成的数组，否则为空数组；
- arr.sort()：对数组进行排序，可以传入一个函数作为参数，该函数有两个参数a（第一个用于比较的元素），b（第二个用于比较的元素），然后返回值应该是一个数字，其正负性表示两个元素的相对顺序，不传参数则会将所有元素转换为字符串，然后按照UTF-16码元顺序比较字符串，并进行排序；
- arr.reduce()：对数组中的每一项执行传入的reducer函数，每次运行会将上次reducer函数的结果作为参数传入，最后将所有的结果汇总成单个返回值；

## 1.2 indexOf和includes的区别

indexOf是用===来进行判断的，因为NaN不等于任意值，因此无法识别出NaN；

indexOf无法识别数组中的空槽，而includes会将空槽视为undefined；

```js
const arr = [1, NaN, , 3]

console.log(arr.indexOf(NaN)) // -1

console.log(arr.includes(NaN)) // true

console.log(arr.indexOf(undefined)) // -1

console.log(arr.includes(undefined)) // true
```

因此，如果我们平时想判断某个元素是否在数组中，最好使用includes。

## 1.3 sort方法

- sort可以接收一个参数或不接收参数；
- sort不接收参数时会将不为undefined的数据转换为字符串，然后根据它们的UTF-16 码元值升序排序；
- sort在接收参数时，参数必须是一个函数，且参数有两个参数，分别代表第一个被比较的值和第二个被比较的值，并且参数的返回值必须是一个数字；
- sort允许数组有空槽，排序时，空槽会移动到数组末尾，并排在所有undefined元素之后；
- sort方法在不同浏览器内部实现原理不一样，有的通过快速排序实现，有的通过多种排序算法实现。

### 1.3.1 默认比较行为

```js
const arr = ['你', '好', '啊']

console.log(arr[0].charCodeAt(0)) // 20320

console.log(arr[1].charCodeAt(0)) // 22909

console.log(arr[2].charCodeAt(0)) // 21834

console.log(arr.sort()) // ['你', '啊', '好']
```

### 1.3.2 传入参数时比较行为

- 当我们传参时，假设参数函数中的两个参数为a，b，我们可以直接返回a - b或b - a；
- 当返回结果为负数时，a在b前，当返回结果为正数时，a在b后，当结果为0时，保持原位置；

```js
const arr = [3, 1, 2]

arr.sort((a, b) => {

    return a - b

})

console.log(arr)

// output: [1,2,3]

const arr = [3, 1, 2]

arr.sort((a, b) => {

    return b - a

})

console.log(arr)

// output: [3,2,1]
```

### 1.3.3 比较特殊类型时

当数组中全都是非NaN和Infinity的数字时，我们可以简单的将返回值设置为a-b或b-a，
但是如果a和b不是一个数字类型时，排序结果往往就会不正常了，这时候需要我们自己对排序函数进行处理；

```js
const arr = [

    {

    name: 'a',

    age: 3

    },

    {

    name: 'b',

    age: 6

    },

    {

    name: 'c',

    age: 1

    }

]

arr.sort((a, b) => {

    if (a.age > b.age) return 1

    if (a.age === b.age) return 0

    return -1

})

console.log(arr)

// output: [{name: 'c', age: 1}, {name: 'a', age: 3}, {name: 'b', age: 6}]
```

### 1.3.4 undefined和空槽的处理

- sort方法会将undefined移动到末尾；
- sort方法会将空槽移动到undefined之后；

```js
const arr = [, undefined, , 1, undefined, 3, 2]

console.log(arr.sort())

// output:  [1, 2, 3, undefined, undefined, empty × 2]
```

## 1.4 reduce方法

reduce的主要作用是对数组每一项执行callback，并将该次执行的结果作为下次callback的参数传递进去；
如果调用reduce的数组为空，并且没有默认值，就会抛出异常。

reduce方法接收两个参数

- 第一个参数是一个函数（callback）：有三个参数，第一个参数是上一次调用该函数的结果（如果是第一次执行，如果设置了默认值，该值就是默认值，没有设置默认值该值就是arr[0]），
- 第二个参数是默认值（ initialValue 可选的）：是当前元素的值（如果设置了默认值，第一次执行，该值就是arr[0]，如果没有默认值，该值就是arr[1]），第三个参数是调用了reduce的数组；

### 1.4.1 无默认值

```js
const arr = [1, 2, 3, 4, 5, 6]

const res = arr.reduce((prev, next) => {

    return prev + next

})

const strRes = arr.reduce((prev, next) => {

    return prev.toString() + next.toString()

})

console.log(res) // 21

console.log(strRes) // '123456'
```

无默认值时会将数组第0项作为默认值，并从第1项开始执行callback函数。

### 1.4.2 有默认值

```js
const arr = [1, 2, 3, 4, 5, 6]

const res = arr.reduce((prev, next) => {

    return prev + next

}, 0)

const strRes = arr.reduce((prev, next) => {

    return prev.toString() + next.toString()

}, 0)

console.log(res) // 21

console.log(strRes) // '0123456'
```

有默认值时会将传入的参数作为默认值，并从第0项开始执行callback函数。

## 1.5 Array.from

对于一个伪数组，可以直接使用Array.from进行转换成数组。

- Array.from可以对一个可迭代对象或类数组对象创建一个新的数组；
- Array.from可以接收三个参数，第一个参数为要转换的对象，第二个参数为一个函数，该函数可以对第一个参数的每一项进行处理，第三个参数为显式绑定this；

```js
function getArguments() {
    return Array.from(arguments, x => x * 2)
}

const arr = getArguments(1, 2, 3, 4, 5, 6)
console.log(arr) // [2, 4, 6, 8, 10, 12]
arr.pop()
console.log(arr) //  [2, 4, 6, 8, 10]
```

## 1.6 多维扁平化

可以递归遍历数组，如果发现该项还是一个数组，就递归遍历，将每一项的值放进一个新数组，进行返回。同时我们也可以使用数组的arr.flat方法。

arr.flat(num)接收一个参数，该参数决定了数组降维的层级，默认为1，如果值为 Infinity，那么会进行无限层的降维，直至数组的层级为1。

```js
const arr = [[1, 2], 3, [6, 7]]

const newArr = arr.flat(1)

console.log(newArr) // [1, 2, 3, 6, 7]

const arr = [[[[[[[[[1]]]]]]]]]

const newArr = arr.flat(Infinity)

console.log(newArr) // [1]
```

## 1.7 随机排序

通过sort方法，只需要将返回值的正负性变为随机就好（数据量较大时不推荐）。

```js
const arr = [1, 2, 6, 90, 58, 26]

    arr.sort((a, b) => {

    // Math.random()生成一个[0, 1)的随机数

    // 如果当前生成的随机数>0.5，返回值为正数，反之为负数

    return Math.random() - 0.5

    })

console.log(arr) // [1, 26, 2, 6, 58, 90]
```

## 1.8 数组遍历

- for循环：可以通过数组长度进行遍历，然后通过索引进行访问；
- forEach：可以直接获取数组每一项的值，并且可以获取索引，还可以改变this指向；
- map：不光可以遍历数组的每一项，还可以对进行增删改查并返回一个新数组；
- for...in：只能遍历出数组的索引，想要获取数组的值，需要通过索引访问；
- for...of：只能遍历出数组每一项的值，不能获取到索引；
  效率方面：for循环 > for...of > forEach >  map > for...in

## 1.9 退出for循环

for循环：可以直接使用break或者return进行退出循环；

for...of：可以使用break退出循环，但是不能使用return（会报错）；
for...in：可以使用break退出循环，但是不能使用return（会报错）；

forEach：按理来说不能退出循环，在其中使用return时，只是退出当前循环的后续步骤，但还会开启下次循环，
但是可以使用抛出异常这种非常规方法终止循环，在外层用try...catch进行错误捕获；

map：不能退出循环，和forEach一样，内部是回调函数，函数内不能写break，如果return只是返回当前值而已；

## 1.10 数组去重

数组去重可以创建新数组，然后遍历数组，然后判断每一项是否存在于新数组中，不存在就添加进去，否则就继续判断下一项，最后返回新数组；
ES6之后可以利用Set数据结构的特性，对数组进行去重，将数组每一项添加到Set中，然后通过Array.from将Set转换为数组，返回这个数组。

# 2. 对象

## 2.1 判断两个对象相等

（1）使用“==”、“===”进行判断

==不能判断对象是否相等；

===判断两个对象是否相等，判断的是它们的引用地址和值是否都相等；

```js
const obj1 = {

  key: 1

}

const obj2 = {

  key: 1

}

const obj3 = obj1

console.log(obj1 === obj2) // false, 因为obj2是重新创建的一个对象，他们两个在内存中存储的地址不同

console.log(obj1 === obj3) // true
```

## 2.2 遍历对象

通过遍历整个对象，拿到每一个key和与其对应的value，去和另一个对象中的key: value进行对比，如果都相同，就返回true，否则返回false。

通过这种方式对比，要考虑对象内部是否有其它对象，如果有的话则需要递归遍历判断；

通过这种方式对比，得到的只是值是否相等，而不是地址是否相等；

## 2.3 判断对象为空

JSON.stringfy：通过使用JSON.stringify(obj) === '{}'来判断是不是一个空对象；

Object.keys(obj)：该方法会返回对象可枚举的字符串键属性名组成的数组，如果最终结果的length属性为0，说明是空对象，该方法只能返回类型为字符串的键名，如果对象中有Symbol的键名，返回的数组也为空；

Reflect.ownKeys(obj)：返回一个由目标对象自身的属性键组成的数组，如果数组长度为0，说明是空对象，该方法不止会返回对象中类型为字符串的键名，还会返回类型为Symbol的键名；

## 2.4 遍历对象属性

可以使用for...in循环；
可以使用Object.keys(obj).forEach()实现遍历；
可以使用Object.values(obj).forEach()，不过该方法只能遍历每一个属性的值；
可以使用Reflect.ownKeys()实现遍历；
可以使用Object.entries()，它返回一个二维数组，数组的每一项为对象的每一个属性的key、value组成的数组；
可以使用Object.getOwnPropertyNames()和Object.getOwnPropertySymbols()分别遍历所有非Symbol的key和所有Symbol的key。

## 2.5 防止对象的值不被修改

可以使用Object.freeze()冻结一个对象；
可以使用Object.defineProperty()给对象每个属性变为不可写的。
