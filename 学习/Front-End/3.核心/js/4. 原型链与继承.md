# 1. 原型和原型链

JavaScript中所有对象都有一个内置属性（[[对象的原型Prototype]]），而这个内置属性指向其<构造函数>的原型（prototype）
对象的原型的本质也是一个对象，因此原型对象也有自己的原型，
直至null，null没有原型，没有这种形成类似链条关系的结构，我们称为原型链。

## 1.1 对象原型

访问对象原型的标准方法为Object.getPrototypeOf()；
可以通过Object.setPrototypeOf()去设置对象的原型；
可以通过Object.prototype.isPrototypeOf()去检查一个对象是否存在于另一个对象的原型链中；
可以通过someObj.hasOwnProperty(key)去判断一个对象的key是存在于该对象本身还是存在于该对象的原型链上；
我们也可以通过obj.[[Prototype]]（在大多数浏览器中实现为obj.__proto__，并不允许通过[[Prototype]]去访问）去访问对象的原型；
对象的原型（[[Prototype]]）指向它的构造函数的prototype属性；

```js
const obj = {
    test: 1
  }

 const prototype = Object.getPrototypeOf(obj)

 console.log(prototype === obj.__proto__) // true
 console.log(Object.prototype === obj.__proto__) // true
 console.log(Object.prototype === prototype) // true
```

## 1.2 原型链

既然这个是对象类型的属性，而原型对象也是对象，那么原型对象就也有这个属性，但是原型对象的__proto__又是指向哪呢？

我们来分析一下，既然原型对象也是对象，那我们只要找到对象的构造函数就能知道__proto__的指向了。而js中，对象的构造函数就是Object()，所以对象的原型对象，就是Object.prototype。既然原型对象也是对象，那原型对象的原型对象，就也是Object.prototype。不过Object.prototype这个比较特殊，它没有上一层的原型对象，或者说是它的__proto__指向的是null。

所以上面的关系图可以拓展成下面这种：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fb087ced09e45a5b8e20a4af5be6173~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)
到这里，就可以回答前面那个问题了，如果某个对象查找属性，自己和原型对象上都没有，那就会继续往原型对象的原型对象上去找，这个例子里就是Object.prototype，这里就是查找的终点站了，在这里找不到，就没有更上一层了（null里面啥也没有），直接返回undefined。

可以看出，整个查找过程都是顺着__proto__属性，一步一步往上查找，形成了像链条一样的结构，这个结构，就是原型链。所以，原型链也叫作隐式原型链。

正是因为这个原因，我们在创建对象、数组、函数等等数据的时候，都自带一些属性和方法，这些属性和方法是在它们的原型上面保存着，所以它们自创建起就可以直接使用那些属性和方法。

# 3. 继承

首先我们要知道，js中的继承都是基于原型链的。

## 3.1）冒充继承

冒充继承顾名思义，并非真正意义上的继承，将父类的构造函数作为子类的一个内部方法，从而实现继承父类属性的一种操作。

js复制代码function Parent(name) {

    this.name = name

    this.getName = function () {

    console.log(this.name)

    }

}

Parent.prototype.sex = '男'

function Child(name) {

    this.parent = Parent

    this.parent(name)

    // 此时执行

    // this.name = name

    // this.getName = function () { console.log(this.name) }

    // 这时子类已经继承了所有的父类属性和方法，内部多了一个this.parent = Parent， 只需删掉

    delete this.parent

}

const child = new Child('Lee')

child.getName() // Lee

console.log(child.name) // Lee

console.log(child.sex) // undefined

优点：这种方式可以实现多继承；

缺点：无法继承父类原型链上的属性和方法；

缺点：需要将父类需要的参数依次传递过去；

## 3.2）原型继承

原型继承就是将父类的实例作为子类的原型。

js复制代码function Parent(name) {

    this.name = name

    this.arr = [1, 2, 3]

}

Parent.prototype.sex = '男'

function Child() {

    this.age = 18

}

// 将子类的原型对象指向父类的实例

Child.prototype = new Parent('Lee')

// 由于子类的原型指向了父类的实例，因此子类的constructor变成了父类，而正常构造函数的prototype中的constructor应该指向它自己

// 我们手动改变

Child.prototype.constructor = Child

const child1 = new Child()

const child2 = new Child()

console.log(child1.name) // Lee

console.log(child1.arr) // [1, 2, 3]

console.log(child1.sex) // 男

child1.arr.pop()

console.log(child2.arr) // [1, 2]

优点：可以继承父类原型链上的属性；

缺点：不能通过将参数传递给子类的方式再将参数传递给父类；

缺点：当父类有引用类型的数据时，所有实例会共享，修改其中一个，会影响其他实例；

## 3.3）构造函数继承

构造函数继承指的就是在子类内部改变父类构造函数的this指向，将父类构造函数的this指向子类的this，以达到继承的目的。

js复制代码function Parent(firstName, lastName) {

    this.name = firstName + lastName

    this.arr = [1, 2, 3]

}

Parent.prototype.sayHi = 'hi'

function Child(firstName, lastName) {

    // 调用父类并传参

    Parent.call(this, firstName, lastName)

    // 或者使用

    // Parent.apply(this,[firstName,lastName])

}

let child1 = new Child('Lee', 'Hi')

let child2 = new Child('Lee', 'Hi')

child1.arr.pop()

console.log(child1.sayHi) // undefined

console.log(child1.arr) // [1, 2]

console.log(child1.name) // Lee Hi

console.log(child2.arr) // [1, 2, 3]

优点：子类可以传参，并将参数传递给父类；

优点：子类实例的所有属性和方法独享，修改其中一个实例的值，不会影响其他实例；

缺点：只能继承父类已经实现的方法，无法继承父类原型链中的方法；

## 3.4）组合继承

组合继承就是原型继承和构造函数的结合。

js复制代码function Parent(firstName, lastName) {

    this.name = firstName + lastName

    this.arr = [1, 2, 3]

}

Parent.prototype.sayHi = 'hi'

function Child(firstName, lastName) {

    Parent.call(this, firstName, lastName)

}

// 将子类的原型对象指向父类的实例

Child.prototype = new Parent('', '')

Child.prototype.constructor = Child

let child1 = new Child('Lee', 'Hi')

let child2 = new Child('Lee', 'Hi')

console.log(child1.name) // LeeHi

console.log(child1.sayHi) // hi

child1.arr.pop()

console.log(child1.arr) // [1, 2]

console.log(child2.arr) // [1, 2, 3]

优点：实现了构造函数继承和原型继承的优点（子类可以传参、不同实例的属性和方法独享、继承了父类原型链的属性）；

缺点：调用了多次父类的构造函数（使用Parent.call时会调用一遍，new Parent时又调用了一遍）；

## 3.5）寄生继承

寄生继承就是封装一个构造函数，该构造函数接收一个对象，并将该对象作为原型，创建一个新对象，新对象会继承原对象以及原对象原型链上的所有属性和方法，然后在新对象上添加私有方法和属性。

js复制代码// ES5

// 封装一个函数，该函数接收一个对象，函数内部创建一个空的构造函数

// 将该对象作为构造函数的原型

// 返回一个构造函数的实例（空对象）

function strongObj(obj) {

    function Fun(){}

    Fun.prototype = obj

    return new Fun()

}

// ES6

// ES6中新增了一个Object.create(obj | null)方法；

// 该方法通过传入一个对象，创建一个以这个对象为原型的新对象，等同于上述strongObj函数

const obj = {

    name: 'obj',

    arr: [1, 2, 3]

}

obj.__proto__.sayHi = 'hi'

function Child(obj) {

    let child = Object.create(obj)

    child.self = 'self'

    return child

}

const obj1 = Child(obj)

const obj2 = Child(obj)

console.log(obj1.name) // obj

console.log(obj1.sayHi) // hi

obj1.arr.pop()

console.log(obj1.arr) // [1, 2]

console.log(obj2.arr) // [1, 2]

优点：可以继承原型上的属性和方法；

优点：创建出来的新对象在Child方法中新增的属性独享；

缺点：只能给Child函数传递参数，不能给父类（原始对象）传递参数；

## 3.6）寄生组合继承

其实组合继承的缺点就是多次调用了父类构造函数，如果能将这一点改变，就近乎完美了，而寄生组合继承就是解决了这个问题。

寄生组合继承主要是改变了组合继承中的Child.prototype = new Parent()这一步，可以直接使用Child.prototype = Parent.prototype，就可以省去一次Parent函数的调用，但是这样又会引发新的问题，这样操作的话，Child的原型和Parent的原型在内存中就指向同一块地址，当我们修改Child的原型属性时，Parent的原型属性也会被影响。

寄生继承的思路可以让我们解决这个问题，使用Object.create(Parent.protype)创建一个新对象，将这个对象作为Child.prototype，就解决了所有问题，这也是为什么叫做寄生组合式继承，它是寄生继承和组合继承的结合，寄生组合式继承是ES5中近乎完美的继承方法。

js复制代码function Parent(firstName, lastName) {

    this.name = firstName + lastName

    this.arr = [1, 2, 3]

}

Parent.prototype.sayHi = 'hi'

function Child(firstName, lastName) {

    Parent.call(this, firstName, lastName)

}

// 将子类的原型对象指向父类的实例

Child.prototype = Object.create(Parent.prototype)

Child.prototype.constructor = Child

let child1 = new Child('Lee', 'Hi')

let child2 = new Child('Lee', 'Hi')

console.log(child1.name) // LeeHi

console.log(child1.sayHi) // hi

child1.arr.pop()

console.log(child1.arr) // [1, 2]

console.log(child2.arr) // [1, 2, 3]

## 3.7）Class继承

ES6之前，所有的继承都是通过开发者自己封装实现的，官方并没有给出一个继承的属性，在ES6之后，有了class关键字，它代表一个类。

Class有几个关键字class、constructor、super、extends。

class代表声明一个类；

constructor代表构造函数；

super相对于通过call、apply调用父构造函数并改变this指向；

extends代表继承；

类中的所有方法，除了构造函数方法中的属性和方法外，其他都挂载在类的原型链上；

js复制代码class Parent {

    constructor(firstName, lastName) {

    this.name = firstName + lastName

    this.arr = [1, 2, 3]

    }

    sayHi() {

    console.log('sayHi')

    }

}

class Child extends Parent {

    constructor(firstName, lastName) {

    super(firstName, lastName)

    this.selfName = 'child'

    }

}

const child1 = new Child('Lee', 'Hi')

const child2 = new Child('Lee', 'Hi')

console.log(child1.name) // LeeHi

child1.sayHi() // hi

child1.arr.pop()

console.log(child1.arr) // [1, 2]

console.log(child2.arr) // [1, 2, 3]

console.log(new Parent())

class可以实现ES5继承中的所有操作；

sayHi方法没有定义在constructor中，因此它会被挂载到Parent类的原型属性上；
