# 1. 定义函数的方法

## 1.1 函数的组成

函数由函数关键字、函数名、形参、函数体组成，其中函数名在特定条件下可以省略。

## 1.2 定义函数的方式

### 1.2.1 函数声明：

由函数关键字、函数名、形参、函数体组成。

```js
function myFun(params) {
    console.log('function body')
}
```

### 1.2.2 函数表达式：

通过声明变量，并且将函数赋值给变量的方式进行定义函数，函数声明中可以省略函数名，变量名作为函数名。

```js
const myFun = function(params) {
    console.log('function body')
}
```

### 1.2.3 构造函数：

通过函数的构造函数Function来创建函数。

```js
const myFun = new Function('a', 'b', 'console.log(a + b)')
```

## 1.3 函数的类型

- 具名函数：具有函数名的函数，一般用函数声明进行声明；
- 匿名函数：没有函数名的函数，一般用于立即执行函数中；
- 立即执行函数：无需调用立马执行的函数，一般都是匿名函数，它必须由()包裹起来，并且在后面跟上()，用于立即调用函数。为了防止js引擎解析错误，最好在立即执行函数之前添加;；

```js
;(function (params) {
    console.log('function body')
})()
```

- 箭头函数：在ES6中新增的函数写法没有函数关键字、没有函数名、只有形参和函数体，并且由=>连接的函数。

```js
const myFun = () => {
    console.log('function body')
}
```

# 2. 函数的参数

- 函数可以接收一个或多个参数；
- 在函数定义阶段中的参数称之为形参；
- 在函数调用阶段中的参数称之为实参；

## 2.1 普通函数中的arguments

当我们在定义函数时，并没有给函数设置形参，但是在实际调用时，却传入了实参，这时候可以通过函数中的arguments来接收；

- arguments是一个对象，而非一个数组，也可称它为类数组（伪数组）；
- 它通过数组索引的方式去获取值，但是并没有数组实例的方法；
- 它是数组中内置的一个对象，不用我们手动设置，自动存放传入的参数信息；

```js
function myFun() {
    console.log(arguments instanceof Array) // false
    console.log(arguments[0]) // 1
    console.log(arguments[1]) // 2
    console.log(arguments[2]) // 3
}

myFun(1, 2, 3)
```

## 2.2 箭头函数中的arguments

箭头函数中不存在arguments。

## 2.3 剩余参数...args

- 如果函数的最后一个命名参数以...为前缀，则它将成为一个由剩余参数组成的真数组，
- 其中从0（包括）到theArgs.length（排除）的元素由传递给函数的实际参数提供。

```js
const myFun = (...args) => {
    console.log(args) // [1,2,3]
}

myFun(1, 2, 3)

function myFun2(a, b, ...args) {
    console.log(args) // [3]
}
myFun2(1, 2, 3)
```

剩余参数即支持箭头函数，也支持普通函数。

## 2.4 剩余参数和arguments的区别

剩余参数以...为前缀，arguments是一个单独的变量名；
剩余参数需要在形参中定义，arguments不需要定义可以直接访问；
剩余参数可以以任何变量名命名，arguments是固定的变量名；
剩余参数返回的是除了已接收参数以外的参数，arguments是所有接收的参数；
剩余参数是真数组，arguments是伪数组；

# 3. 函数中的this指向

在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定）。this不能在执行期间被赋值，并且在每次函数被调用时 this 的值也可能会不同。

## 3.1 this指向什么

在全局调用时，this的值默认指向Window对象；
this的绑定和***代码编写的位置***没有关系；
this的绑定和***调用的方式***有关系；

```js
console.log(this) // Window

function myFun() {
    console.log(this)
}

const obj = {
    myFun
}

myFun() // Window

obj.myFun() // { myFun: f() }
```

## 3.2 默认绑定

在默认情况下（即函数独立调用，并没有绑定在某个对象上调用时），this的指向都为Window（严格模式下为undefined）。

## 3.3 箭头函数的this

箭头函数进行显式this绑定无效；
箭头函数的this指向它父级的this（当我们改变箭头函数父级的this时，箭头函数的this也跟着改变了）；

## 3.4 隐式绑定

当函数被某个对象调用时，函数的this就会自动指向**调用它的对象**，这种行为可以称之为隐式绑定。
通过隐式绑定我们可以大概搞明白，为什么在全局中的函数调用会绑定Window了，因为fun()其实就相当于Window.fun()，是Window对象调用了fun函数。

## 3.5 显式绑定

通过call、apply、bind可以手动设置函数的this，并且可以根据不同的规则给函数传参，这种方式称之为显式绑定。

js为我们提供了三种显示绑定this的方法，分别为call、apply、bind。
三者的第一个参数：都是要绑定的this的值；

- call的 传参方式是一个列表，在原有函数上绑定
- apply的传参方式是一个数组，在原有函数上绑定
- bind的 传参方式是一个列表，返回一个新函数

```js
const obj = {
    name: "obj",
    a: 20,
    b: 30,
};

function add(c) {
    console.log(this.a + this.b + c);
}

add.call(obj, 10); // 60
add.apply(obj, [30]); // 80
const newFun = add.bind(obj, 20);
newFun(); // 70
```

## 3.6 内置函数的this绑定

```js
const names = ["1", "2", "3"];
names.forEach(function (item) {
    console.log(this); // Window
});

"use strict";
const names = ["1", "2", "3"];
names.forEach(function (item) {
    console.log(this); // undefined
});

const obj = {
    name: "obj",
};

const names = ["1", "2", "3"];
    names.forEach(function (item) {
    console.log(this); // {name: 'obj'}
}, obj);
```

拿forEach函数举例，默认非严格模式情况下指向Window，严格模式下为undefined，某些内置函数的参数允许传递this，我们可以通过传参的方式绑定this。

## 3.7 new关键字绑定（new的过程发生了什么）

首先要搞明白，new的过程发生了什么？

创建一个全新的对象；
将该对象的原型（即__proto__）指向其构造函数的prototype属性；
将该对象作为this；（绑定this）；
如果没有返回新的对象，就会将该对象进行返回；

由代码实现（简易版）如下（以new Array为例）：

```js
const obj = Object.create(null)

obj.__proto__ = Array.prototype

const result = Array.call(obj)

return typeof result === 'object' ? result : obj
```

## 3.8 特殊场景的this绑定

显式绑定为undefined、null

```js
function myFun() {
    console.log(this);
}

myFun.call(undefined); // Window
myFun.apply(null); // Window

"use strict";
myFun.call(undefined); // undefined
myFun.apply(null); // null
```

显式绑定为undefined、null时，在非严格模式下会忽略显示绑定，使用默认规则，this的值为Window，而在严格模式下，就是undefined和null。

间接函数引用

```js
function myFun() {
    console.log(this);
}

const obj = {
    name: "obj",
    myFun: myFun,
};

const obj1 = {
    name: "obj1",
};

obj.myFun(); // obj

(obj1.myFun = obj.myFun)(); // Window

"use strict";
(obj1.myFun = obj.myFun)(); // undefined
```

因为(obj1.myFun = obj.myFun)这个式子的返回值是myFun函数，因此最后一步其实就变成了myFun()，就相当于默认绑定，所以在非严格模式下为Window，严格模式下为undefined。

## 3.9 各种this绑定规则的优先级

默认绑定规则优先级最低；
隐式绑定规则其次；
显式绑定规则高于隐式绑定；
内置函数传参相当于显式绑定；
new绑定优先级高于bind；

new绑定无法和call、apply同时使用，因此不存在谁的优先级高；
new绑定可以和bind一起使用，但是new绑定的优先级更高；

# 4. 闭包

## 4.1 概念

闭包是那些能够访问自由变量的函数。
自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。

## 4.2 闭包的作用和缺点

- **访问外部变量**：闭包可以记住并访问创建它的外部函数的作用域中的变量，即使外部函数已经执行完毕。
- **变量持久性**：由于闭包能够访问外部变量，这些变量在外部函数执行完毕后仍然被保留，不会被垃圾回收机制回收，直到闭包本身被销毁。
- **函数作为值传递**：闭包允许将函数作为值传递给其他函数，或者作为对象的属性赋值。
- **封装性**：闭包提供了一种封装数据和逻辑的方式，使得数据和操作数据的函数能够紧密地联系在一起。
- **记忆性**：闭包可以“记忆”上一次调用的状态，因为它们可以访问外部函数的变量。

## 4.3 使用场景

- **数据私有化**：通过闭包可以创建私有变量，防止外部直接访问。
- **模块化**：闭包常用于创建模块，封装公共API和私有实现。
- **函数工厂**：使用闭包可以创建具有不同行为的函数，每个函数可以记住上一次的状态。
- **柯里化**：将一个多参数的函数转换成一系列单参数的函数。
- **事件处理**：在事件处理器中使用闭包可以访问包含事件上下文的变量。
- **缓存和记忆**：闭包可以用来实现缓存，避免重复计算。
- **异步编程**：在回调函数中使用闭包可以保持异步操作的状态。

# 5. 构造函数

构造函数就是一种特殊的函数，它的定义更像是类

它通常和new操作符一起使用，创建一个实例（也就是对象）。
该实例会继承来自构造函数的所有方法和属性；

- 构造函数都有一个属性prototype，构造函数创建出来的实例会继承prototype上的方法；
- 构造函数创建出来的实例也有自己的一个内置属性[[Prototype]]（__proto__），该属性指向构造函数的prototype；
- 构造函数prototype上有一个属性constructor，该属性指向构造函数本身；
  按照规范来说，构造函数名称的首字母必须大写，普通的函数也可以当作构造函数使用。

```js
function Person(name, age) {
    this.name = name
    this.age = age
}

function person(name, age) {
    this.name = name
    this.age = age
}

const p = new Person('lee', 18)
const p2 = new person('lee', 19)
console.log(p) // Person {name: 'lee', age: 18}
console.log(p2) // person {name: 'lee', age: 19}
```

# 6. 尾递归优化

尾递归优化就是在进行递归操作时，递归函数的最后一步是调用本身，而没有其他任何操作。
尾递归优化依赖于js引擎，在ES6中提出了尾递归优化，但是还有很多浏览器没有进行适配。
尾递归优化例子

```js
// 求阶乘
function factorial(num) {
    if (num <= 0) return 1
    return num * factorial(num - 1)
}

function newFactorial(num, prevRes) {
    if (n === 0) return prevRes
    return newFactorial(num - 1, num * prevRes)
}
```

在第一个函数中，每次递归时还有一步*num的运算，而第二个函数，最后一步只是调用自身，并没有其他操作。这种方式就可以使用尾递归优化。
尾递归优化了什么
来看第一个函数的执行过程：

创建全局上下文，函数调用栈中加入全局上下文；
执行factorial函数，函数调用栈加入factorial上下文；
执行到最后一步，为num * factorial(num - 1)，这时候需要计算factorial(num - 1)的值，于是函数调用栈中又加入一个factorial上下文；
如果我们传入的num是一个很大的数，此时为了等待返回值，函数调用栈可能已经创建了很多函数执行上下文了，最终就会爆栈，爆栈溢出的错误；

而如果我们使用了尾递归优化，当递归函数的最后一步只调用自身时，执行到return时，函数调用栈会将当前上下文移除，只把返回值保存起来，然后加入新的函数执行上下文，每执行一次都会弹出，然后换新的进来，这样一来，我们的函数调用栈永远就只会有全局上下文和当前活跃的函数上下文了，就可以有效的防止栈溢出问题。
如何开启尾递归优化
因为目前许多浏览器还没有对尾递归进行优化，就算有进行优化的也只在严格模式下生效，于是想让浏览器进行尾递归优化，必须要开启严格模式。

```js
function optimizeFactorial(num) {
    // 执行严格模式
    "use strict";
    function newFactorial(num, prevRes) {
      if (n === 0) return prevRes
      return newFactorial(num - 1, num * prevRes)
    }
    return newFactorial(num, 1)
}
```

# 7. 函数柯里化

函数柯里化其实就是将一个多参数的函数转换为一系列单参数的函数，每个单参数函数都可以接收一个参数，并返回一个新的函数。柯里化可以使函数更加灵活和可重用，避免重复的代码。

比如：

```js
function add(x, y, z) {

    return x + y + z

}

add(1, 2, 3)

function addCurrying(x) {

    return function (y) {

    return function (z) {

    return x + y + z

    }

    }

}

addCurrying(1)(2)(3)
```

以上就是函数柯里化的一种情况，但是这是在我们知道传参个数的情况下，如果我们不确定传参个数，那么应该返回几层函数呢，或者说，如果调用者想通过add(1,2)(3)这种方式调用呢？

（1）函数柯里化的实现

编写柯里化函数，将一个多参数函数生成单参数函数。

```js
function add(x, y, z) {

    return x + y + z

}

function curry(fn) {

    // 获取到原函数接收几个参数

    const funLen = fn.length

    // 返回一个函数

    return function backFun(...args) {

    // 记录此次传入的参数数组

    const params = args

    // 如果此次传入的参数个数 >= 原函数所需要的参数了, 直接调用原函数并返回结果

    if (params.length >= funLen) {

    return fn(...args)

    } else {

    // 如果此次传入的参数还不满足执行原函数的条件, 继续返回一个函数

    return function (...args) {

    // 拿到此次函数的参数, 通过apply, 将此次参数和上次参数合并起来, 调用backFun              函数, 再次进行判断参数是否够用, 不够继续返回新函数

    return backFun.apply(null, params.concat(args))

    }

    }

    }

}

const fun = curry(add)

console.log(fun(1)(2)(3)) // 6

console.log(fun(1, 2)(3)) // 6

console.log(fun(1, 2, 3)) // 6
```

可以简写成以下写法：

```js
const curry = (fn, ...args) => {

    if (args.length >= fn.length) {

    return fn(...args)

    } else {

    return (...nextArgs) => {

    return curry(fn, ...args, ...nextArgs)

    }

    }

}

const fun = curry(add)

console.log(fun(1)(2)(3)) // 6

console.log(fun(1, 2)(3)) // 6

console.log(fun(1, 2, 3)) // 6
```

它具体执行的流程是这样的：

第一次我们执行curry函数，只传入了原函数，此时args为空数组，if判断不满足，走else；

else语句返回了一个函数，fun的值就是(...nextArg) => curry(fn, ...args, ...nextArgs)；

执行fun(1)(2)(3)，会先执行fun(1)，就相当于执行curry(add, 1)，依旧走了else判断；

然后执行fun(1)(2)，此时args的值为[1]，nextArgs的值为[2]，于是相当于执行curry(add, 1, 2)；

继续执行，执行到fun(1)(2)(3)时，相当于执行了current(add,1,2,3)，发现if判断满足；

执行add(1,2,3)，返回正确值；

（2）函数柯里化的作用

参数复用：比如我们第一次计算了1+2+3的值，后来我们想计算1+2+5的值：

按照普通函数，我们会这么做，第一次执行add(1,2,3)，第二次执行add(1,2,5)；

按照柯里化，我们可以先拿到1+2，执行const res = curry(1,2)，以后无论想+5还是+8，只需要调用res(n)就可以了。

提前返回：当函数分批次的接收参数时，它会先把一部分参数进行判断，然后返回对应的函数，下次调用时就不需要判断这部分参数了。

延迟执行：通过柯里化返回的函数，都不会立即执行，而是在我们需要调用时才会执行，这种就叫做延迟执行。
