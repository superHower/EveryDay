# 1. TCP、UDP

## 1.1. TCP特点

TCP协议是一种面向连接的、可靠传输的、基于字节流的、全双工传输层通信协议。

- 1.面向连接
  使用TCP协议之前，必须先进行TCP连接，也就是我们常说的三次握手，数据传输完毕之后，关闭已经建立的TCP连接，也就是我们常说的四次挥手，它的连接只能有两个端点，也就是说，它的连接是一对一的。
- 2.全双工通信
  全双工通信指的就是通信双方都具有接收和发送信息的能力。
- 3.可靠传输
  TCP协议的连接是一对一的，且是全双工通信，发送端会将数据分段，然后给每一段数据进行编号，然后发出，当接收端收到数据，并且返回确认消息（ACK应答报文），发送端接收到应答消息之后，才会继续发送下一段数据，如果没有收到确认消息，就会重发这一段消息。

```plain
比如有两个端点A和B进行了连接，A里有1，2，3三段数据要发送给B：

A先发送1数据，此时发送窗口还保留着a，b在后面排队；
B接收到了1数据，将确认消息发送给了A，并且A接收到了；
A继续开始发送2数据......

正因为有了这种编号机制和确认应答机制，才不会导致数据混乱或是数据丢失，才保证了TCP协议传输的可靠性。

```

- 4.基于字节流的
  TCP是将一条用户消息根据滑动窗口的字节大小，拆分成多个TCP报文段（TCP将数据看作一连串字节流）；
- 5.滑动窗口
  因为普通的发送和应答太浪费时间，一次只能发送一组数据，等到这组数据的应答返回时，才能继续发送下一组，因此滑动窗口出现了，滑动窗口的出现就是允许一次发送多组数据，然后返回一个ACK就继续发送下一组数据。

```plain
1. 滑动窗口的大小是通过TCP协议头部的“窗口大小” 字段，来进行控制的；
2. 操作系统为了维护滑动窗口，开辟发送缓冲区，记录了哪些数据没有应答，应答之后才会从缓冲区删掉；
```

- 6.流量控制
  接收端处理数据的速度是有限的。如果发送端发送的速度太快，导致接收缓冲区占满（接收缓冲区包含了按序到达但尚未被应用程序读取的数据，不按序到达以及尚未进入接收窗口的数据。），这个时候如果发送端继续发送，就会造成丢包，继而引起丢包重传等等一系列连锁反应。流量控制的目的就是让发送端可以根据接收端的实际接收能力控制发送的数据量。

```plain
1. TCP协议的头部信息中，有一个16位字段的窗口大小，窗口大小的内容就是接收缓冲区的剩余大小，可以通过ACK报文将该字段告知发送端；
2. 接收端一旦发现自己的缓冲区快满了，就会将窗口大小设置成一个更小的值通知给发送端;
3. 如果接收端缓冲区满了，就会将窗口设置为0；这时发送方不再发送数据，但是需要定期发送一个窗口探测数据段，使接收端把窗口大小告诉发送端；
```

- 7.拥塞控制
  虽然TCP有了滑动窗口这个功能，能够高效可靠的发送大量的数据。但是如果在刚开始阶段就发送大量的数据，仍然可能引发问题，比如当前网络状态比较拥堵，如果一开始就发送较多数据，就会造成堆积。而拥塞控制的出现，就是根据当前的网络状态对发送数据进行限制。
  拥塞控制引入了拥塞窗口的概念，它是发送端维护的一个变量，根据网络拥塞情况变大或变小，当发出的数据没有接到应答时，会被发送端认为网络出现了拥塞，就会减少拥塞窗口的值，如果接收到了应答，就会增加拥塞窗口的值，所以说最终发送端的发送量，是由拥塞窗口和滑动窗口的最小值进行决定的。

```plain
1. 慢启动：一开始不要传输大量数据，先试试水，如果网络状态还行，每次收到1个应答，那就拥塞窗口大小+1，下次发送n个数据，这时候拥塞窗口大小就增加n，这时，拥塞窗口呈指数级增长，直到达到慢启动的阈值，当拥塞窗口小于慢启动阈值时，采用慢启动算法；
2. 拥塞避免：当拥塞窗口大于等于慢启动阈值时，采用拥塞避免，此时每次收到n个应答（n就是拥塞窗口的值），拥塞窗口大小增加1，这时拥塞窗口呈线性级增长；
3. 拥塞发生：当发现网络拥塞，也就是发送的数据无应答时，说明发生了网络拥塞，这时候会将慢启动阈值设置为拥塞窗口的1/2，然后拥塞窗口重置为1，重新启动慢启动算法；
4. 快速重传：就是接收方在收到失序的报文后立即发出一个重复的ACK，如果只是1~2个重复的（前一个包）ACK，说明只是短暂的延时造成的失序，无需进行处理，如果发送三次相同的的ACK，发送端就会认为包丢失了，就会立即重传对方尚未收到的报文段，而不用继续等待超时再重传；
5. 快速恢复：快速恢复算法认为，发送端能收到3个确认报文，说明接收端接收情况还是可以的，网络情况还行，于是就重新发送丢失的报文，并且继续执行避免拥塞的算法，不需要使用慢启动；
```

## 1.2. UDP特点

UDP是一个无连接的、不可靠的、面向报文的传输层通信协议；
它拥有以下特点：

- 无连接的
  使用UDP协议通信的双方，发送数据之前不需要进行连接，发送数据后，也不需要断开连接，减少了开销，正因为它是无连接的，因此它可以支持1对多；
- 不可靠的
  UDP尽最大努力交付，但不保证可靠交付、不保证数据的顺序，即使发生丢包，也不会返回任何错误信息；
- 面向报文
  UDP只是个搬运工，发送端发送的报文，UDP不会进行拆分、合并，仅保留报文的边界，添加了首部之后就交付给IP层；
- 没有拥塞控制
  即使网络拥塞，UDP也不会降低传输效率；

## 1.3. TCP和UDP的区别是什么，谁更好？

（1）区别

TCP更加安全可靠，UDP不可靠；
TCP只支持1对1，UDP可支持1对多和1对1
TCP发送数据之前需要连接，UDP则不需要，因此TCP效率不如UDP；
TCP首部开销大，最小20字节，最大60字节，UDP首部开销小，仅有8字节；
TCP面向字节流，可将报文拆分成多段进行发送，而UDP面向报文，不可拆分报文；
TCP拥有拥塞控制、流量控制等手段，而UDP没有这些手段，不会降低发送效率；

（2）谁更好
TCP和UDP之间没有谁更好，TCP更加可靠，而UDP效率更高，特定的使用场景下，它们都有各自的好处；
TCP的优点在于它是安全可靠的，因此在一些以安全为重的场景下，TCP无疑是最好的；
UDP的优点在于它效率非常高，因此在一些以效率为重的场景下，即使发生丢包也没什么太大影响的场景下，UDP的优势就会非常明显；

## 1.4. 流量控制和拥塞控制的区别是什么

流量控制是根据接收端接收能力的大小，对发送端的发送数量进行限制；
拥塞控制是根据网络承载能力的大小，对发送端的发送数量进行限制；
二者结合，才是最终发送端发送的数量，即取二者的最小值；

# 2. 三次握手和四次挥手

三次握手是通信两端建立连接的过程；
四次挥手是通信两端断开连接的过程；

## 2.1.三次握手的过程

发送端向接收端发送SYN报文，进行第一次握手；
接收端接收到SYN报文，然后回复SYN报文和ACK报文给发送端，进行第二次握手；
发送端接收到SYN和ACK报文，然后继续发送SYN报文给接收端，进行第三次握手；

## 2.2.三次握手的意义

之所以进行三次握手，是要确认发送端和接收端都有发送和接收的能力；

第一次握手，发送端进行发送，证明了发送端有发送能力；
接收端接收到了发送端发送的数据，知道了发送端拥有发送能力，但是接收端不知道发送端是否有接收能力，于是进行第二次握手；
发送端接收到了接收端返回的报文，知道了接收端拥有接收和发送的能力，但是我也应该让它知道我接收到了它的信息，于是又进行第三次握手，再次发送报文给接收端，告知接收端，我接收到你的消息了，可以建立连接了；

## 2.3.三次握手改成两次握手不行吗？

不行！
我们从确认彼此收发能力的角度看，两次握手确实已经足够，比如在第二次握手之后，我们就可以进行连接，然后发送端就开始发送数据，接收端一看，你发来数据了，说明你收到我刚才给你的信息了，这不是也可以证明彼此都有收发信息的能力了吗？
但是我们看一下下面这个场景：

发送端发送了一个SYN报文，然后发送端因为某种原因宕机了，而且这个报文被网络阻塞了，接收端并没有收到；
过了一会，发送端恢复正常，然后又重新发了一个SYN报文，这时候，前一个SYN报文被接收端先收到了，然后接收端返回了一个对应前一个报文的ACK；
发送端收到这个ACK，心想，不对啊，这不是我刚发出去的那一个啊；

三次握手就是为了防止这种建立历史连接的场景发生，在三次握手的情况下，接下来会发生如下操作：

发送端发现不对劲之后，就会发送一个RST报文；
接收端收到发送端发送的RST报文就会意识到，原来我接收错了，于是就会释放连接，等待正确的SYN报文；

而如果是两次握手，在发送端接收到错误的ACK之后就已经建立了连接，没有机会通知接收端“你接收错了”。
如果新的SYN报文在RST报文发送之前就被接收端收到了会怎么样呢？这时接收端还会将上一次的ACK报文发送给发送端，发送端收到之后，还是会发送RST报文给接收端；

## 2.4.三次握手的过程中可以携带数据吗

第一次第二次不可以，因为此时还没有建立连接，第三次握手是可以的，因为第三次握手的时候发送端已经建立连接了，它也知道接收端的收发能力是正常的了，是可以携带数据的。

## 2.5.四次挥手的过程

第一次挥手，发送端发送FIN报文给接收端；
第二次挥手，接收端回复ACK报文，表明我收到了你要断开连接的请求；
第三次挥手，接收端发送FIN报文给发送端；
第四次挥手，发送端发送ACK报文给接收端，表明我收到了你断开连接的请求，然后发送端经过2MSL之后断开连接，接收端收到发送端的ACK报文之后，立马断开连接；

## 2.6.四次挥手的意义

因为TCP是全双工通信，不能单方面断开连接，因此必须双方都断开连接的情况下才能断开连接。

## 2.7.四次挥手可以携带数据吗

第一次挥手，发送端是要准备断开连接的，这时已经不允许发送端继续发送数据了；
第二次挥手，发送端只是不能发送数据，但还没有关闭接收数据的能力，接收端如果有没处理完的数据，还是可以继续发送给发送端的；
第三次挥手，接收端也打算断开连接，关闭自己发送数据的能力了，因此也是不能发送数据的；
第四次挥手，都不能进行发送数据了，准备断开连接了；

## 2.8.四次挥手最终等待2MSL的原因是什么

RFC协议规定了MSL为2分钟，2MSL就是4分钟。
假设这种情况，第四次挥手中，发送端发送ACK给接收端，这时候如果发生丢包，接收端未接收到发送端发送的ACK，那么接收端就会重新发送FIN，请求断开。
而等待2MSL就是为了应对这种情况，当发送端又接收到接收端发送的FIN报文后，会重新发送ACK报文，并且再次等待2MSL；

# 3. TCP/IP协议

TCP/IP是能够在多个不同网络间实现信息传输的协议簇；
TCP/IP协议不只是有TCP和IP协议，像HTTP、UDP也属于其中的一种；
主要是因为TCP协议和IP协议最具代表性，采用它们俩的名字来命名；

# 4. DNS

域名系统（英文：Domain Name System：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。

也就是说，DNS主要用途其实就是将域名解析成对应IP的。

## 4.1. DNS查询方式

- **递归查询**
  递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归查询，用户只需要发出一次查询请求。
- **迭代查询**
  迭代查询指的是查询请求发出后，域名服务器返回单次查询的结果，下一级的查询由用户自己请求，使用迭代查询，用户需要发出多次的查询请求。

## 4.2.DNS查询流程

比如我们想访问网页A，它的网址为www.a.com：

- 浏览器会查看浏览器缓存中有没有该域名的IP缓存；
- 如果没有，就会去本机的hosts文件查看有没有该域名的IP缓存；
- 如果还没有，浏览器就会请求本地域名服务器；
- 本地域名服务器会先查询自己的DNS缓存；
- 如果还没有，本地域名服务器则会向根域名服务器发起请求，根服务器会返回顶级域名服务器的地址；
- 然后本地域名服务器会向顶级域名服务器发送二级域名，进行请求，获取权威域名服务器地址；
- 然后本地域名服务器向权威域名服务器地址发送请求，拿到IP地址；
- 本机和浏览器会将该IP地址进行缓存；

```plain
比如www.a.com，其中完整的写法为www.a.com.，最后的.就是根域名，访问时可以被忽略，而.com就是顶级域名，a.com就是权威域名。
在本地域名服务器之前，进行的都是递归查询，因为我们就发起了一次域名的查询，递归查询了浏览器缓存、hosts文件、本地域名服务器。
但是在本地域名服务器向根域名服务器发出请求之后，就全部都是迭代查询了，因为根域名服务器返回了一个顶级域名服务器地址，还是需要本地域名服务器再次请求。
```

## 4.3. DNS为什么选择UDP协议作为传输层协议

在解析域名获得IP地址的过程中，往往会多次向不同的域名服务器发出请求，而TCP协议存在三次握手，会造成DNS解析变得很慢，使用UDP协议，不需要进行三次握手，提升了查询的效率。

## 4.4. DNS实现负载均衡

DNS负载均衡技术的实现原理是在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时，DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。

# 5 WebSocket

## 5.1. 什么是webSocket

WebSocket是一种在单个TCP连接上进行全双工通信的协议；
WebSocket API也被W3C定为标准；
WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。

## 5.2. 和HTTP的区别

相同点：
都是基于TCP协议的可靠的应用层协议。

不同点

- WebSocket是全双工通信协议，通信双方可以在同一时间同时发送和接收消息，而HTTP是单向的；
- WebSocket需要依赖HTTP协议和服务器完成一次握手，然后就可以创建持久性的连接，而HTTP每次都需要重新建立连接（当然，也可以完成持久连接）；
- WebSocket 数据格式比较轻量，它的数据包头部较小，而HTTP协议每次通信都需要携带完整的头部；
- WebSocket没有跨域问题；
- WebSocket可以由服务端主动推送消息；

## 5.3. WebSocket握手与HTTP握手的区别

WebSocket的握手报文相比HTTP的握手报文，多了两个属性：

1. Upgrade:webSocket（代表要在HTTP协议的基础上升级为WebSocket）；
2. Connection:Upgrade（代表要对协议进行升级）；

协议升级成功之后，服务端就会返回101状态码，客户端收到101状态码后就成功。

## 5.4. WebSocket 心跳机制

可能会有某些未知情况导致 socket 断开，而客户端和服务端却不知道，需要客户端定时发送一个“心跳（ping） 让服务端知道自己在线；
服务端也需要回答一个“心跳”（pong） 告诉客户端自己可用，否则视为断开。
WebSocket状态
ConstantValueWebSocket.CONNECTING（正在连接）0
WebSocket.OPEN                   （连接成功）1
WebSocket.CLOSING                （正在关闭）2
WebSocket.CLOSED      （已经关闭或者连接失败）3

## 5.5. WebSocket和Socket的区别是什么

- Socket是TCP/IP网络的API，是为了方便使用TCP或UDP而抽象出来的一层，是位于应用层和传输控制层之间的一组接口；
- WebSocket则是一个典型的应用层协议;

## 5.6. 即时通讯方案

- 短轮询：客户端定时向服务端发送请求，获取更新；
- 长轮询：是对短轮询的改进，请求到服务端后会被挂起，直到有数据更新，才会进行响应，然后由客户端再次发起请求；
- SSE：基于HTTP协议中的持久连接，作为HTML5的新功能，不用客户端发起请求，数据发生改变时，允许服务端主动推送数据到客户端；
- WebSocket：通过WebSocket可以允许服务端主动推送数据到客户端；
- Socket.io：其实Socket.IO只是为了解决websocket的兼容性的一个解决方案，因为websocket出现的较新，所以一些老的浏览器兼容性不好，而Socket.IO就是将websocket、长轮询两种通信方式封装成了统一的通信接口进行降级兼容；

# 6. CDN技术

概念： 是一组分布在各个地区的服务器。
    这些服务器存储着数据的副本，可以选择与用户距离最近的服务器，来满足数据的请求。

    是一种网络技术，资源本质上还是存储在某一台服务器上的，CDN只是帮你找到距离你最近的服务器

好处：

1. CDN 提供快速服务，较少受高流量影响。
2. 分流，降低根服务器压力。
3. 实现跨运营商、跨地域的全网覆盖，减少传输时间。
4. 客户端连接代理服务器，可以隐藏根服务器IP，更安全。
5. 一台服务器发生故障，系统会调用其他临近的健康服务器节点进行服务，更可靠。

# 7 计算机网络模型

## 7.1 OSI七层模型:

即Open System nterconnection，开放系统互连。它分为: 应用层、表示层、会话层、传输层、网络层、数据链路层、物理层 。

- 应用层、表示层、会话层三个层次提供的服务相差不是很大，所以在TCP/IP协议中，它们被合并为应用层一个层次。 

TCP/IP五层模型：应用层、传输层、网络层、数据链路层、物理层；

- 应用层协议： HTTP、WebSocket、DNS、HTTPS等协议；
- 传输层协议： TCP、UDP、TLS协议；
- 网络层协议： IP；

## 7.2 各层作用

- 应用层：直接为应用进程提供服务，应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议；
- 表示层：数据格式化、加密、解密；
- 会话层：建立、维护、管理会话连接；
- 传输层：提供端对端的连接；
- 网络层：IP寻址和路由选择；
- 数据链路层：在网络层和物理层之间，负责向网络层提供服务；
- 物理层：通过光缆、无线电波等方式连接组网，传输比特流；

# 8. 单工通信、半双工通信、双工通信是什么

单工通信就是指: 通信双方只有有一方发送数据，另一方负责接收数据；
半双工通信就是: 通信双方都具有发送和接收数据的能力，但是不能同时进行，比如A在发送数据时，B只能接收，不能发送；
全双工通信就是: 双方都具有发送和接收数据的能力，并且可以同时进行；

# 9. 在浏览器中输入内容到按下回车，发生了什么？

输入：浏览器会查看输入的是一个完整的URL还是一个关键字，如果是一个关键字，就会将其拼装成一个完整的URL进行访问；
检查缓存：检查当前浏览器是否有该URL的缓存，如果命中了强缓存，就直接使用缓存；
DNS解析：如果没有命中强缓存，则需要发起请求，这时会根据域名进行DNS解析，通过递归查询和迭代查询，得到最终的IP地址；
建立TCP连接：查找到IP之后进行TCP连接，进行三次握手；
发送请求：发送HTTP请求，请求时会带上cookie中保存的缓存标识；
服务器处理请求：服务器网关请求之后，会在服务器内部对请求进行处理，具体如何处理，和服务器有关；
服务器响应请求：服务器处理完请求之后，如果命中了协商缓存，就返回304状态码，如果请求失败，就返回对应的状态码，如果请求成功，就返回200状态码；
浏览器接收响应：浏览器收到服务器的响应，根据服务器是否开启了持久连接，来决定是断开连接还是继续保持TCP连接，并且还会缓存响应头中缓存相关的标识；
开始页面渲染：浏览器进行生成DOM树、生成CSSOM树、解析js脚本、合并Render树、计算样式、生成布局树（Layout）、分层、下达绘制指令、分块、光栅化、画等操作；
