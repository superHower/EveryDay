
## 1. HTTP概念
HTTP，即超文本传输协议，是用于从网络传输超文本到本地浏览器的传输协议。

- **超文本**：不仅包括文本，还能嵌入图片、视频、音频等内容，以及重要的**超链接**，使得文本内容可以相互跳转，形成复杂的非线性和网状结构。例如，`HTML`就是一种超文本标记语言。
- **传输**：指的是信息从一个地方传递到另一个地方的过程。
- **协议**：是通信双方必须共同遵守的规则和标准。

总的来说，`HTTP`是互联网上应用最为广泛的协议之一，它定义了浏览器和服务器之间请求和响应的标准。

## HTTP特点

- **无状态**：服务器不会存储关于客户请求的任何信息，每次连接后立即断开，使得单个网页服务器可以同时处理更多请求。
- **无连接**：早期HTTP/1.0不支持持久连接，每个TCP连接只能发送一个请求和响应。HTTP/1.1引入了持久连接，减少了TCP连接的建立和关闭的消耗。
- **可靠传输**：HTTP协议依赖于TCP/IP协议栈，TCP协议提供了可靠的数据传输。
- **灵活可拓展**：HTTP协议支持多种请求方法和状态码，允许传输多种类型的数据。

## 2. HTTP报文组成

(1) 请求报文
- **请求行**：包含`请求方法`、`请求地址`、`HTTP协议版本号`。
- **请求头**：包含请求的附加信息，如`Host`、`User-Agent`等。
- **空行**：用于分隔请求头和请求体。
- **请求体**：通常在非GET请求中使用，如POST请求中附带的数据。

(2) 响应报文
- **响应行**：包含`HTTP协议版本号`、`状态码`、`状态码的英文描述`。
- **响应头**：提供响应的附加信息，如`Content-Type`、`Content-Length`等。
- **空行**：用于分隔响应头和响应体。
- **响应体**：服务器返回的具体内容。

## 3. HTTP的请求方法
HTTP1.0定义了`GET`、`POST`、`HEAD`三种方法，HTTP1.1新增了`PUT`、`DELETE`、`OPTIONS`、`TRACE`、`CONNECT`五种方法。

- **GET**：请求指定的资源。
- **POST**：向指定资源提交数据，常用于表单提交。
- **HEAD**：与GET方法类似，但只返回响应头信息。
- **PUT**：上传文件或数据，请求服务器进行存储。
- **DELETE**：请求删除指定的资源。
- **OPTIONS**：用于跨域请求的预检。
- **TRACE**：请求服务器回显其收到的请求信息。
- **CONNECT**：保留将来使用。

### 3.1.GET与POST的区别

- **约定语义**：GET用来无副作用的请求资源，理应幂等，即参数相同时多次请求的结果不变，而POST一般用来传递数据，进行新增、修改、删除等操作
- **缓存**：GET请求可以被缓存，POST请求默认不缓存。如果想进行缓存，可以通过代理服务器实现缓存;
- **参数**：GET请求的参数通过URL传递，POST请求的参数通过请求体传递。
- **安全性**：GET请求参数直接暴露在URL中，POST请求参数在请求体中，对用户不可见，但对服务器和中间网络设备可见。
- **回退/刷新**：GET请求可以安全地进行回退和刷新，POST请求如果回退或刷新可能会导致数据重复提交。
- **编码**：GET请求只能进行URL编码，POST请求支持更复杂的编码。
- **效率**：GET请求通常更高效，因为它只需要一个TCP数据包，而POST请求需要两个。

### 3.2.为什么GET请求长度限制

HTTP协议规范并没有对URL长度进行限制，但由于参数是拼接在URL之后的，浏览器和服务器对URL长度有实际的限制。

### 3.3.PUT与POST的区别

- **约定语义**：PUT请求是幂等的，意味着多次执行同一个PUT请求应该保持资源状态不变；POST请求不是幂等的，多次执行可能会导致资源状态变化。
- **用途**：PUT和POST都可以用来创建或修改资源，但PUT更倾向于上传文件或全量更新资源，而POST则更灵活，可以用于创建新资源或进行部分更新。

### 3.4.OPTIONS请求的作用

OPTIONS请求通常用于CORS（跨源资源共享）的预检。当浏览器需要向非同源服务器发送请求时，会先发送一个OPTIONS请求，以确定服务器是否允许跨域请求。如果服务器同意，才会继续发送实际的请求。
## 4. HTTP常见的请求头

### 4.1 `头部字段`分类：
- **通用字段**： 响应头和请求头都可以出现的字段。
- **请求字段**： 只在请求头中出现，补充请求信息或额外的条件。
- **响应字段**： 只在响应头中出现，补充响应报文的信息。
- **实体字段**： 属于通用字段，专门描述body的额外信息。

### 4.2 常见的请求头

- **HOST**：HTTP1.1中必须出现的字段，告诉服务器请求由哪个主机处理。
- **User-Agent**：描述发起HTTP请求的客户端。
- **Date**：HTTP报文创建的时间，通常出现在响应头中。
- **Server**：告诉客户端提供Web服务的软件名称和版本号。
- **Content-Length**：请求体或响应体的长度。
- **Accept**：浏览器能够处理的内容类型。
- **Accept-Charset**：浏览器能够显示的字符集。
- **Accept-Encoding**：浏览器能够处理的压缩编码。
- **Accept-Language**：浏览器当前设置的语言。
- **Connection**：浏览器与服务器之间连接的类型。
- **Cookie**：当前页面设置的任何Cookie。
- **Referer**：发出请求的页面的URL。
- **Content-Type**：服务器返回数据类型的MIME类型。

### 4.3.Content-Type的格式
`Content-Type：type/subtype ;parameter`

- **type**：主类型，如`application`。
- **subtype**：子类型，如`x-www-form-urlencoded`。
- **parameter**：可选参数，如`charset`、`boundary`。

### 4.4.常见的Content-Type的值

- `application/x-www-form-urlencoded`：表单数据序列化。
- `multipart/form-data`：表单中进行文件上传。
- `application/json`：请求体内容是JSON格式的字符串。

## 5. HTTP常见的状态码

状态码是十进制数字，表示服务器对请求的处理结果。

### 5.1状态码分类

- **1xx**：提示信息，表示目前是协议处理的中间状态，还有后续的操作
- **2xx**：成功，请求被正确处理。
- **3xx**：重定向，资源位置变动。
- **4xx**：客户端错误，请求有误。
- **5xx**：服务器错误，内部发生错误。

### 5.2具体状态码及含义

- 100：（客户端继续发送请求，这是临时响应）这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应；
- 101：客户端使用Upgrade头字段，要求在HTTP协议基础上改成其他协议继续通信，如果服务器同意变更，则返回101状态码，后续数据传输就改用新的协议；
- 103（Early Hints）：客户端应在服务端返回HTML前开始预加载资源；
- 200：请求已成功，请求所希望的响应头或数据体将随此响应返回；
- 201：请求已创建，请求成功并且服务器创建了新的资源；
- 202：请求已接受，服务器已经接受请求，但还没处理；
- 203：非授权信息，服务器已成功处理了请求，但返回的信息可能来自另一来源；
- 204：无内容，服务器成功处理请求，但没有返回任何内容；
- 205：重置内容， 服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）；
- 206：处理部分请求，服务器已经成功处理了部分请求，是断点续传和分块下载的基础；
- 300：多种选择，针对请求，服务器可执行多种操作，服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择；
- 301：永久重定向，请求的网页已永久移动到新位置。服务器不会返回资源，而是会自动将请求者转到新的URL，需要告知客户端这个页面地址已经永久变成新的了；
- 302：临时重定向，服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求，不需要告知客户端这个页面地址改变了；
- 303：临时重定向，将POST请求重定向，然后强制以GET方式发送请求；
- 304：缓存重定向，意为资源未修改，可以使用协商缓存的内容，因此也称为缓存重定向；
- 305：使用代理，请求者只能使用代理访问请求的网页，如果服务器返回此响应，表示请求者应使用代理；
- 307：临时重定向，和302类似，但是如果原请求是POST，重定向之后不能以GET请求发出；
- 308：永久重定向，和301类似，但是如果原请求是POST，重定向之后不能以GET请求发出；
- 400：请求语法错误，服务器不理解；
- 401：未授权，要求发起请求的用户进行身份验证，一般对于登录后的网页，服务器才会做此响应；
- 403：拒绝，服务器拒绝了请求；
- 404：资源不存在，请求的资源不存在，服务器找不到；
- 405：方法禁用，发起请求的方法不对；
- 406：不接受，无法使用请求的内容特性响应请求的网页；
- 500：服务器内部错误，服务器内部报错，无法响应请求；
- 501：尚未实施，服务器还未具备完成请求的功能；
- 502：错误网关，服务器作为网关或代理，从上游服务器收到无效响应；
- 503：服务不可用，服务器目前处于不可用状态，比如在维护或超载了，但这只是暂时的；
- 504：网关超时，服务器作为网关或代理，但是没有及时从上游服务器收到请求；
- 505：HTTP 版本不受支持，服务器不支持请求中所用的 HTTP 协议版本；


### 5.3 301、302、303、307、308的关系和区别
302、303、307都是临时重定向，一开始只有302这一个状态码，HTTP1.0规范规定：如果原请求不是GET或HEAD，302状态码不能自动重定向。
- 由于许多浏览器在实现302状态码时，并没有严格遵守规范，即使是POST请求，也会自动进行重定向，并且大多数浏览器还会以GET请求重新发起请求，导致原POST请求参数丢失。为了应对这种情况，HTTP1.1的规范中，新增了303、307、308状态码
- **302**：传统临时重定向，但会被错误实现为自动重定向POST请求。
- **303**：无论GET还是POST请求，都会自动重定向，并且强制以GET请求重新发起请求；
- **307**：和302基本一致，依旧只有GET和HEAD请求可以自动重定向，但是不允许原POST请求以GET请求重新发起请求；
- **308**：和301基本一致，但是不允许原POST请求以GET请求重新发起请求


### 5.4 103状态码

- 正常情况下，我们需要等待HTML页面的返回后，才可以知道下一步需要去加载哪些 JS、CSS文件，这中间有一段的等待时间就被浪费掉了；这尤其在SSR项目中尤为明显；

- HTTP 103 状态码可以返回一个初步的HTTP 响应，浏览器可以使用这些提示来预连接，并在等待资源响应的同时请求子资源；

- 它在 SSR 项目里面会非常有用；在SPA项目里面，大部分的逻辑都在客户端，HTML很小，这时候我们只需要用常规的preload、preconnect之类的手段就可以了；

### 5.5 103状态码和HTTP2服务器推送的区别

- 使用HTTP2服务器推送时，很多资源其实浏览器第一次请求就已经缓存下来了，但是服务端推送仍然会推送已缓存的资源，会导致网络带宽浪费；这是它的一个缺点，所以使用的人也较少；
- HTTP2服务器推送是直接发送资源，而103状态码只是向浏览器发送资源提示，浏览器可以控制是否需要这些资源，因为相同的资源可能已经在浏览器缓存过了；
- 总的来说，HTTP103 （Early Hints） 它能够解决网络带宽浪费的问题，可以说是 HTTP/2 Server Push 的升级版，不过目前还没有完全覆盖服务器推送的所有用例；

# 6. HTTP的版本

HTTP版本有HTTP0.9、HTTP1.0、HTTP1.1、HTTP2以及面向未来的HTTP3。

## 6.1 HTTP1.0

默认不使用持久连接，每次请求都需要建立连接，请求完毕就会断开连接，但是通过设置Connection: keep-alive（默认为close），可以实现长连接；
仅支持GET、POST、HEAD请求方法；
302状态码并未被浏览器按照规范实现；
使用Expires作为判断强缓存是否有效的标准，使用Last-Modified和Last-Modified-Since作为协商缓存是否有效的标准；
不支持断点续传；
产生队头阻塞问题，因为要等待前一次的响应结果返回，才能进行下一次响应，如果前一次请求的响应很慢，那么就会产生阻塞；

## 6.2 HTTP1.1

默认使用持久连接，即默认使用Connection: keep-alive，建立连接之后发送请求，下次发送请求无需重新建立连接；
新增了PUT、DELETE、OPTIONS、CONNECT、TRACE五种请求方法；
新增了303、307、308状态码，将301和302状态码进行区分；
使用cache-control作为判断强缓存是否有效的标准，使用ETag和If-None-Match作为协商缓存是否有效的标准；
支持断点续传，新增了206状态码；
引入管道机制，即在同一个TCP连接中，HTTP请求可以并行，无需等待上一次的请求结果，就可以发送下一个请求，但是服务器必须按照客户端请求的先后顺序进行响应，以便客户端能够正确的拿到响应结果；
并未真正解决队头阻塞问题，管道机制解决了一部分的队头阻塞问题，因为它允许多个请求并行发出，但是它又要求响应结果按顺序返回，如果说某一个请求响应需要很长时间，后续的请求响应必须要等到前一个请求的响应完毕，还是会造成阻塞；
头部开销较大，header中引入了很多的内容，导致每次发送请求都需要携带巨大的头部，开销较大；

## 6.3 HTTP2

默认不再使用ASCII编码传输，而是采用二进制数据，客户端发起请求时，将请求内容封装成带有不同编号的二进制帧（Frame），然后发送给服务端，服务端进行拼接，得到完整的请求信息，然后将响应结果也拆分成二进制帧，客户端再进行拼装，拿到响应结果，在HTTP1.1中，头部是文本，数据部分可以是文本也可以是二进制，但是在HTTP2中，都变成了二进制帧；
多路复用：有了二进制帧之后，只需要建立一个连接即可完成通信需求，这种方式被称为多路复用，每一条路称为stream（流），并且客户端和服务端可以同时发送或响应多个请求，无需按照顺序，避免了队头阻塞问题；
头部信息压缩，使用专门的头部压缩算法，减少数据传输量，主要方式是通过客户端和服务端同时维护一张头部信息表，所有的头部信息都会在表里记录，并且对应一个索引，下次发起请求时只需要携带索引即可，比如第一次发送请求A，依然会把请求头带过去，但是客户端和服务端会记录下来该请求的请求头，并维护在一张表里，下次再次发送请求A的时候，就去表里找有没有请求A的请求头，如果有，只带一个索引即可；
服务器主动推送：允许服务端主动向客户端推送数据，是Chrome106版本禁用了，改为103状态码；
数据流：HTTP2中，因为数据传输不是有序的，所以同一个TCP连接中，相连的两个数据包不是同一个请求的，为了区分这种情况，每个请求或响应的数据包称之为一个数据流（stream），每一个数据流都有一个唯一的编号，以便客户端或者服务端能够根据编号将它们分类、组装成一个完整的请求或响应；

## 6.4 HTTP3

Goole发明了一个基于UDP协议的QUIC协议，并在HTTP3上使用QUIC。
QUIC协议基于UDP，无需进行建立连接，省去了三次握手的过程，速度更快；
同样也提供了拥塞控制机制，包括慢启动、拥塞避免等；
也实现了多路复用的功能，每个请求会在 QUIC 中为一个 stream，并且相互隔离，就算发生丢包也只影响当前stream；
也实现了类似TCP的可靠传输，比如发送第n个数据，TCP中只有收到了接收端的ACK报文，才会发送n+1，而QUIC中，不管接收端有没有接收，都会发送n+1，只不过n+1中的数据，标识还是为n，我们可以把每次发送的数据当作一个流stream，每个stream可以传输多个stream offset，而stream offset指向的就是n，接收端即使拿到了n+1的数据，进行拼装的时候还是会根据n来拼装；
集成了 TLS 加密功能，目前QUIC使用的是TLS1.3，相较于早期版本，TLS1.3有更多的优点，其中最重要的一点是减少了握手所花费的RTT个数。

## 6.5 为什么HTTP3会出现

HTTP3最大的改变就是它采用了基于UDP协议的传输协议，之所以会诞生出HTTP3，是因为之前的HTTP协议都是基于TCP的，而TCP协议天生在性能上就有一些缺陷。

TCP协议是需要连接的，所以就必须要进行三次握手，而UDP协议是无连接的，节省了三次握手；
TCP协议就是会有可能产生队头阻塞问题，无法改变；

队头阻塞
TCP协议是可靠的，所以它必须等到前一个数据传输完成，并且接收到接收端发回的响应，才会继续发送下一个数据，如果前一个数据丢包了，那就要等待重传，否则后面的数据都需要排队，也就是说，把TCP连接看成一个队列，只要队头的不动，后面的都别想动。
这种机制保证了TCP协议的安全可靠性，但是也会影响性能问题。
队头阻塞的解决方案

HTTP1.1中使用管道机制，允许多个请求并行，但是响应数据必须按照顺序，所以说在数据响应时，还是会造成队头阻塞；
HTTP2中，直接放弃管道机制，把数据改为了二进制帧进行传输，利用编号来将这些帧进行分组拼装，不需要按顺序发送或返回，一定程度上解决了队头阻塞，但是由于底层协议还是TCP，如果数据发生丢包，当前连接内的所有内容都要等待重传，还是会造成阻塞；
HTTP3为了彻底解决队头阻塞问题，直接将底层协议改为基于UDP协议实现；

## 6.6 HTTP1.1、HTTP2、HTTP3总结

下一个版本一定是对上一个版本缺点的修复，比如HTTP1.1中安全性不高、性能不足，在HTTP2中对其进行了头部压缩、多路复用、采用TLS加密传输等优化，但是还存在队头阻塞的问题，HTTP3又直接修改底层协议，彻底解决队头阻塞问题，即拥有TCP协议的安全可靠性，又具有UDP协议的性能。

# 7. HTTPS协议

HTTPS并不是一个新的协议，它是在HTTP和TCP的传输中建立了一个安全层，它其实就是由HTTP协议+SSL/TLS协议组合而成，本质上还是HTTP协议，只是由SSL/TLS进行了安全性的提升。
## 7.1 HTTPS优缺点
1.优点
- 相比于HTTP协议来说，它更加安全；
- HTTPS对搜索引擎更友好，利于 SEO，谷歌、百度优先索引 HTTPS 网页；
- 使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；

2. 缺点
- HTTPS证书需要及时维护，并且还要花钱；
- HTTPS加密解密需要消耗更多服务器资源；
- HTTPS在握手阶段比较耗时；

## 7.2 和HTTP的区别
- HTTP是明文传输，HTTPS可以进行加密传输，更加安全；
- HTTPS标准端口 443，HTTP标准端口 80；
- HTTPS需要用到SSL证书，而HTTP不用；

## 7.3 SSL/TLS协议是什么

SSL(Secure Sockets Layer 安全套接层),传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议，TLS与SSL在传输层对网络连接进行加密。

## 7.4 HTTPS的握手
### 握手流程

- 客户端发起 HTTPS 请求，发送客户端生成的随机数和支持的加密算法列表；
- 服务端返回证书信息、服务端生成的随机数、选择使用的加密方法给客户端；
- 客户端对证书进行合法性验证，验证通过后再生成一个随机数;
- 客户端通过证书中的公钥对随机数进行加密传输到服务端，服务端接收后通过私钥解密得到该随机数；
- 三次握手此时已经完成，之后客户端和服务端都会根据这三个随机数，生成一个随机对称密钥，之后的数据都通过随机对称密钥进行加密传输。

### 如何验证证书的合法性

- 首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验；
- 浏览器接着判断证书中的颁发者CA是否受信任，用以校验证书是否为合法机构颁发；
- 如果证书不可信，浏览器就会提示证书不可信；
- 如果证书可信，那么浏览器就会用 CA机构 的公钥对证书里面的签名进行解密，得到hash值和加密算法；
- 再用证书里提到的加密算法，将证书的明文内容加密成另一个hash值，对比两个hash值是否相同，相同则证明服务器发来的证书合法，没有被篡改；
- 再比对一下证书中的域名和当前请求的域名是否一致，以确保证书不会被掉包；
- 此时浏览器就可以读取证书中的公钥，用于后续加密了。

### 为什么需要三个随机数
通过使用多个随机数，可以增加密钥的复杂性和安全性，提高加密算法的强度，更好的保护数据。
